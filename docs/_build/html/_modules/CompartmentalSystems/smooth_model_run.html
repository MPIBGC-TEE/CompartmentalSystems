<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>CompartmentalSystems.smooth_model_run &mdash; CompartmentalSystems 1 documentation</title>
    
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="CompartmentalSystems 1 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for CompartmentalSystems.smooth_model_run</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Module for numerical treatment of smooth reservoir models.</span>

<span class="sd">An abstract </span>
<span class="sd">:class:`~.smooth_reservoir_model.SmoothReservoirModel` is </span>
<span class="sd">filled with live by giving initial values, a parameter set, a time grid, </span>
<span class="sd">and potentially additional involved functions to it.</span>

<span class="sd">The model can then be run and as long as the model is linear,</span>
<span class="sd">based on the state transition operator age and transit time</span>
<span class="sd">distributions can be computed.</span>

<span class="sd">Nonlinear models can be lineaized along a solution trajectory.</span>

<span class="sd">Counting of compartment/pool/reservoir numbers start at zero and the </span>
<span class="sd">total number of pools is :math:`d`.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>

<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="k">import</span> <span class="n">cm</span>
<span class="kn">import</span> <span class="nn">matplotlib.patches</span> <span class="k">as</span> <span class="nn">mpatches</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.mplot3d</span> <span class="k">import</span> <span class="n">Axes3D</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">import</span> <span class="nn">plotly.graph_objs</span> <span class="k">as</span> <span class="nn">go</span>

<span class="kn">import</span> <span class="nn">pickle</span>

<span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">lambdify</span><span class="p">,</span> <span class="n">flatten</span><span class="p">,</span> <span class="n">latex</span><span class="p">,</span> <span class="n">Function</span><span class="p">,</span> <span class="n">sympify</span><span class="p">,</span> <span class="n">sstr</span>
<span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">_clash</span>

<span class="kn">from</span> <span class="nn">scipy.integrate</span> <span class="k">import</span> <span class="n">odeint</span><span class="p">,</span> <span class="n">quad</span> 
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="k">import</span> <span class="n">interp1d</span><span class="p">,</span> <span class="n">UnivariateSpline</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="k">import</span> <span class="n">newton</span><span class="p">,</span> <span class="n">brentq</span>

<span class="kn">from</span> <span class="nn">tqdm</span> <span class="k">import</span> <span class="n">tqdm</span>

<span class="kn">from</span> <span class="nn">.smooth_reservoir_model</span> <span class="k">import</span> <span class="n">SmoothReservoirModel</span>
<span class="kn">from</span> <span class="nn">.helpers_reservoir</span> <span class="k">import</span> <span class="p">(</span><span class="n">has_pw</span><span class="p">,</span> <span class="n">numsol_symbolic_system</span><span class="p">,</span> 
    <span class="n">arrange_subplots</span><span class="p">,</span> <span class="n">melt</span><span class="p">,</span> <span class="n">generalized_inverse_CDF</span><span class="p">,</span> <span class="n">draw_rv</span><span class="p">,</span> 
    <span class="n">stochastic_collocation_transform</span><span class="p">,</span> <span class="n">numerical_rhs</span><span class="p">,</span> <span class="n">MH_sampling</span><span class="p">,</span> <span class="n">save_csv</span><span class="p">,</span> 
    <span class="n">load_csv</span><span class="p">,</span> <span class="n">stride</span><span class="p">)</span>


<div class="viewcode-block" id="Error"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.Error">[docs]</a><span class="k">class</span> <span class="nc">Error</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generic error occurring in this module.&quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="SmoothModelRun"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun">[docs]</a><span class="k">class</span> <span class="nc">SmoothModelRun</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class for a model run based on a </span>
<span class="sd">    :class:`~.smooth_reservoir_model.SmoothReservoirModel`.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        model (:class:`~.smooth_reservoir_model.SmoothReservoirModel`): </span>
<span class="sd">            The reservoir model on which the model run bases.</span>
<span class="sd">        parameter set (dict): ``{x: y}`` with ``x`` being a SymPy symbol </span>
<span class="sd">            and ``y`` being a numerical value.</span>
<span class="sd">        start_values (numpy.array): The vector of start values.</span>
<span class="sd">        times (numpy.array): The time grid used for the simulation.</span>
<span class="sd">            Typically created by ``numpy.linspace``.</span>
<span class="sd">        func_set (dict): ``{f: func}`` with ``f`` being a SymPy symbol and </span>
<span class="sd">            ``func`` being a Python function. Defaults to ``dict()``.</span>

<span class="sd">    Pool counting starts with ``0```. In combined structures for pools and </span>
<span class="sd">    system, the system is at the position of a ``(d+1)`` st pool.</span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">parameter_set</span><span class="p">,</span> 
                        <span class="n">start_values</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">func_set</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a SmoothModelRun instance.</span>

<span class="sd">        Args:</span>
<span class="sd">            model (:class:`~.smooth_reservoir_model.SmoothReservoirModel`): </span>
<span class="sd">                The reservoir model on which the model run bases.</span>
<span class="sd">            parameter_set (dict): ``{x: y}`` with ``x`` being a SymPy symbol </span>
<span class="sd">                and ``y`` being a numerical value.</span>
<span class="sd">            start_values (numpy.array): The vector of start values.</span>
<span class="sd">            times (numpy.array): The time grid used for the simulation.</span>
<span class="sd">                Typically created by ``numpy.linspace``.</span>
<span class="sd">            func_set (dict): ``{f: func}`` with ``f`` being a SymPy symbol and </span>
<span class="sd">                ``func`` being a Python function. Defaults to ``dict()``.</span>

<span class="sd">        Raises:</span>
<span class="sd">            Error: If ``start_values`` is not a ``numpy.array``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># we cannot use dict() as default because the test suite makes weird </span>
        <span class="c1"># things with it! But that is bad style anyways</span>
        <span class="k">if</span> <span class="n">parameter_set</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">parameter_set</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">func_set</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">func_set</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="c1">#fixme:</span>
        <span class="c1"># check for completeness and so on and so forth</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameter_set</span> <span class="o">=</span> <span class="n">parameter_set</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">times</span> <span class="o">=</span> <span class="n">times</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_values</span> <span class="o">=</span> <span class="n">start_values</span>
        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">start_values</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="k">raise</span><span class="p">(</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;start_values should be a numpy array&quot;</span><span class="p">))</span>
        <span class="n">func_set</span> <span class="o">=</span> <span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">):</span> <span class="n">val</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">func_set</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func_set</span> <span class="o">=</span> <span class="n">func_set</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_state_transition_operator_values</span> <span class="o">=</span> <span class="kc">None</span>


    <span class="c1"># create self.A(t)</span>

    <span class="c1"># in a linear model, A(t) is independent of the state_variables,</span>
    <span class="c1"># consequently, we can call _A with X = 0,</span>
    <span class="c1"># in a nonlinear model we would need to compute X(t) </span>
    <span class="c1"># by solving the ODE first,</span>
    <span class="c1"># then plug it in --&gt; much slower </span>
    <span class="c1"># --&gt; influences quantiles and forward transit time computation time</span>

    <span class="c1"># --&gt; this should be respected by the class to which the model belongs</span>
<div class="viewcode-block" id="SmoothModelRun.A"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.A">[docs]</a>    <span class="k">def</span> <span class="nf">A</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return :math:`A(t)` with :math:`A` from </span>
<span class="sd">        :math:`\\dot{x} = A\\,x+u.`</span>

<span class="sd">        Args:</span>
<span class="sd">            t (float): The time at which :math:`A` is to be evaluated.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: The compartmental matrix evaluated at time ``t``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_A&#39;</span><span class="p">):</span>
            <span class="c1">#fixme: what about a piecewise in the matrix?</span>
            <span class="c1"># is this here the right place to do it??</span>
            <span class="n">cm_par</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">compartmental_matrix</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameter_set</span><span class="p">)</span>
            <span class="n">tup</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">state_vector</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">time_symbol</span><span class="o">.</span><span class="n">name</span><span class="p">,)</span>
            <span class="n">cut_func_set</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">[:</span><span class="n">key</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;(&#39;</span><span class="p">)]:</span> <span class="n">val</span> 
                                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_set</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="n">A_func</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span><span class="n">tup</span><span class="p">,</span> <span class="n">cm_par</span><span class="p">,</span> <span class="p">[</span><span class="n">cut_func_set</span><span class="p">,</span> <span class="s1">&#39;numpy&#39;</span><span class="p">])</span>
        
            <span class="k">def</span> <span class="nf">_A</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
                <span class="c1">#print(&#39;A&#39;, t)</span>
                <span class="c1">#fixme: another times cut off!</span>
                <span class="n">t</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="c1">#print(t)</span>
                <span class="c1">#X = self.solve_single_value()(t) # nonlinear model needs that</span>

                <span class="c1"># for a linear model this is OK (and faster)</span>
                <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span><span class="p">,))</span> 
                <span class="n">Xt</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">t</span><span class="p">,)</span>
                <span class="k">return</span> <span class="n">A_func</span><span class="p">(</span><span class="o">*</span><span class="n">Xt</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_A</span> <span class="o">=</span> <span class="n">_A</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>     </div>

<div class="viewcode-block" id="SmoothModelRun.linearize"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.linearize">[docs]</a>    <span class="k">def</span> <span class="nf">linearize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a linearized SmoothModelRun instance.</span>

<span class="sd">        Linearization happens along the solution trajectory. Only for linear </span>
<span class="sd">        systems all functionality is guaranteed,</span>
<span class="sd">        this is why nonlinear systems should be linearized first.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :class:`SmoothModelRun`: A linearized version of the original </span>
<span class="sd">            :class:`SmoothModelRun`, with the solutions now being part </span>
<span class="sd">            of ``func_set``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sol_funcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sol_funcs</span><span class="p">()</span>
        
        <span class="n">srm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span>
        <span class="n">xi</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">srm</span><span class="o">.</span><span class="n">xi_T_N_u_representation</span>
        <span class="n">svec</span> <span class="o">=</span> <span class="n">srm</span><span class="o">.</span><span class="n">state_vector</span>

        <span class="n">symbolic_sol_funcs</span> <span class="o">=</span> <span class="p">{</span><span class="n">sv</span><span class="p">:</span> <span class="n">Function</span><span class="p">(</span><span class="n">sv</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;_sol&#39;</span><span class="p">)(</span><span class="n">srm</span><span class="o">.</span><span class="n">time_symbol</span><span class="p">)</span> 
                                <span class="k">for</span> <span class="n">sv</span> <span class="ow">in</span> <span class="n">svec</span><span class="p">}</span>

        <span class="c1"># need to define a function_factory to create the function we need to </span>
        <span class="c1"># avoid late binding</span>
        <span class="c1"># with late binding pool will always be nr_pools and always the last </span>
        <span class="c1"># function will be used!</span>
        <span class="k">def</span> <span class="nf">func_maker</span><span class="p">(</span><span class="n">pool</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">sol_funcs</span><span class="p">[</span><span class="n">pool</span><span class="p">](</span><span class="n">t</span><span class="p">)</span>

            <span class="k">return</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>

        <span class="n">sol_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">pool</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span><span class="p">):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">sstr</span><span class="p">(</span><span class="n">symbolic_sol_funcs</span><span class="p">[</span><span class="n">svec</span><span class="p">[</span><span class="n">pool</span><span class="p">]])</span>
            <span class="n">sol_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">func_maker</span><span class="p">(</span><span class="n">pool</span><span class="p">)</span>


        <span class="n">linearized_A</span> <span class="o">=</span> <span class="p">(</span><span class="n">xi</span><span class="o">*</span><span class="n">T</span><span class="o">*</span><span class="n">N</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">symbolic_sol_funcs</span><span class="p">)</span>
        <span class="n">linearized_u</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">symbolic_sol_funcs</span><span class="p">)</span>

        <span class="n">func_set</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_set</span>
        <span class="n">func_set</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">sol_dict</span><span class="p">)</span>

        <span class="n">cl</span><span class="o">=</span><span class="n">srm</span><span class="o">.</span><span class="vm">__class__</span>
        <span class="n">linearized_srm</span> <span class="o">=</span> <span class="n">cl</span><span class="o">.</span><span class="n">from_A_u</span><span class="p">(</span>
            <span class="n">srm</span><span class="o">.</span><span class="n">state_vector</span><span class="p">,</span> 
            <span class="n">srm</span><span class="o">.</span><span class="n">time_symbol</span><span class="p">,</span> 
            <span class="n">linearized_A</span><span class="p">,</span> 
            <span class="n">linearized_u</span>
        <span class="p">)</span>      

        <span class="n">linearized_smr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="n">linearized_srm</span><span class="p">,</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">parameter_set</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">start_values</span><span class="p">,</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">,</span> 
            <span class="n">func_set</span><span class="o">=</span><span class="n">func_set</span>
        <span class="p">)</span>
 
        <span class="k">return</span> <span class="n">linearized_smr</span></div>

    <span class="c1"># return an ndarray (moments x pools) </span>
    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="SmoothModelRun.moments_from_densities"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.moments_from_densities">[docs]</a>    <span class="k">def</span> <span class="nf">moments_from_densities</span><span class="p">(</span><span class="n">max_order</span><span class="p">,</span> <span class="n">densities</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the moments up to max_order of the given densities.</span>

<span class="sd">        Args:</span>
<span class="sd">            max_order (int): The highest order up to which moments are </span>
<span class="sd">                to be computed.</span>
<span class="sd">            densities (numpy.array): Each entry is a Python function of one </span>
<span class="sd">                variable (age) that represents a probability density function.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: moments x pools, containing the moments of the given </span>
<span class="sd">            densities.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">densities</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">kth_moment</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">kth_moment_pool</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">pool</span><span class="p">):</span>
                <span class="n">norm</span> <span class="o">=</span> <span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">densities</span><span class="p">(</span><span class="n">a</span><span class="p">)[</span><span class="n">pool</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">infty</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">norm</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span><span class="o">**</span><span class="n">k</span><span class="o">*</span><span class="n">densities</span><span class="p">(</span><span class="n">a</span><span class="p">)[</span><span class="n">pool</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">infty</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> 
                            <span class="o">/</span> <span class="n">norm</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">kth_moment_pool</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">pool</span><span class="p">)</span> <span class="k">for</span> <span class="n">pool</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)])</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">kth_moment</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_order</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span></div>

    
    <span class="c1">########## public methods and properties ########## </span>

    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nr_pools</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;int: Return the number of pools involved in the model.&quot;&quot;&quot;</span>
        <span class="k">return</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">nr_pools</span><span class="p">)</span>

<div class="viewcode-block" id="SmoothModelRun.solve_single_value"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.solve_single_value">[docs]</a>    <span class="k">def</span> <span class="nf">solve_single_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alternative_start_values</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Solve the model and return a function of time.</span>

<span class="sd">        Args:</span>
<span class="sd">            alternative_start_values (numpy.array, optional): If not given, the </span>
<span class="sd">                original ``start_values`` are used.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Python function ``f``: ``f(t)`` is a numpy.array that containts the </span>
<span class="sd">            pool contents at time ``t``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_solve_age_moment_system_single_value</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> 
                        <span class="n">alternative_start_values</span><span class="p">)</span></div>

<div class="viewcode-block" id="SmoothModelRun.solve"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.solve">[docs]</a>    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alternative_times</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">alternative_start_values</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Solve the model and return a solution grid.</span>

<span class="sd">        Args:</span>
<span class="sd">            alternative_times (numpy.array): If not given, the original time </span>
<span class="sd">                grid is used.</span>
<span class="sd">            alternative_start_values (numpy.array): If not given, </span>
<span class="sd">                the original start_values are used.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: len(times) x nr_pools, contains the pool contents </span>
<span class="sd">            at the times given in the time grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_solve_age_moment_system</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">alternative_times</span><span class="p">,</span> 
                        <span class="n">alternative_start_values</span><span class="p">)</span></div>


    <span class="c1">##### fluxes as functions #####</span>
    

    <span class="c1">#fixme: test</span>
<div class="viewcode-block" id="SmoothModelRun.sol_funcs"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.sol_funcs">[docs]</a>    <span class="k">def</span> <span class="nf">sol_funcs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return linearly interpolated solution functions.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Python function ``f``: ``f(t)`` returns a numpy.array containing the</span>
<span class="sd">            pool contents at time ``t``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>

        <span class="n">sol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>
        <span class="n">sol_funcs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span><span class="p">):</span>
            <span class="n">sol_inter</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">sol</span><span class="p">[:,</span><span class="n">i</span><span class="p">])</span>
            <span class="n">sol_funcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sol_inter</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">sol_funcs</span></div>
        
<div class="viewcode-block" id="SmoothModelRun.external_input_flux_funcs"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.external_input_flux_funcs">[docs]</a>    <span class="k">def</span> <span class="nf">external_input_flux_funcs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a dictionary of the external input fluxes.</span>
<span class="sd">        </span>
<span class="sd">        The resulting functions base on sol_funcs and are linear interpolations.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: ``{key: func}`` with ``key`` representing the pool which </span>
<span class="sd">            receives the input and ``func`` a function of time that returns </span>
<span class="sd">            a ``float``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flux_funcs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">input_fluxes</span><span class="p">)</span></div>

<div class="viewcode-block" id="SmoothModelRun.internal_flux_funcs"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.internal_flux_funcs">[docs]</a>    <span class="k">def</span> <span class="nf">internal_flux_funcs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a dictionary of the internal fluxes.</span>
<span class="sd">        </span>
<span class="sd">        The resulting functions base on sol_funcs and are linear interpolations.</span>

<span class="sd">        Returns:</span>
<span class="sd">            ditc: ``{key: func}`` with ``key=(pool_from, pool_to)`` representing</span>
<span class="sd">            the pools involved and ``func`` a function of time that returns </span>
<span class="sd">            a ``float``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flux_funcs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">internal_fluxes</span><span class="p">)</span></div>

<div class="viewcode-block" id="SmoothModelRun.output_flux_funcs"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.output_flux_funcs">[docs]</a>    <span class="k">def</span> <span class="nf">output_flux_funcs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a dictionary of the external output fluxes.</span>
<span class="sd">        </span>
<span class="sd">        The resulting functions base on sol_funcs and are linear interpolations.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: ``{key: func}`` with ``key`` representing the pool from which</span>
<span class="sd">            the output comes and ``func`` a function of time that returns a </span>
<span class="sd">            ``float``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flux_funcs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">output_fluxes</span><span class="p">)</span></div>
    
    <span class="c1">#fixme: here _func indicated that this here is already a function of t</span>
    <span class="c1"># on other occasions _func indicated that a function is returned</span>
<div class="viewcode-block" id="SmoothModelRun.output_vector_func"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.output_vector_func">[docs]</a>    <span class="k">def</span> <span class="nf">output_vector_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a vector of the external output fluxes at time ``t``.</span>
<span class="sd">        </span>
<span class="sd">        The resulting values base on sol_funcs and come from  linear </span>
<span class="sd">        interpolations.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.array: The ``i`` th entry is the output from pool ``i`` at </span>
<span class="sd">            time ``t``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span><span class="p">,))</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_flux_funcs</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">res</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span></div>


    <span class="c1">##### fluxes as vector-valued functions #####</span>
    

    <span class="c1">#fixme: returns a function</span>
<div class="viewcode-block" id="SmoothModelRun.external_input_vector_func"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.external_input_vector_func">[docs]</a>    <span class="k">def</span> <span class="nf">external_input_vector_func</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a vector valued function for the external inputs.</span>

<span class="sd">        The resulting function bases on sol_funcs and is a linear interpolation.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Python function ``u``: ``u(t)`` is a ``numpy.array`` containing the </span>
<span class="sd">            external inputs at time ``t``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">t0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># cut off inputs until t0</span>
        <span class="n">t_valid</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="kc">True</span> <span class="k">if</span> <span class="p">(</span><span class="n">t0</span><span class="o">&lt;</span><span class="n">t</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">t</span><span class="o">&lt;=</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">else</span> <span class="kc">False</span>

        <span class="n">input_fluxes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_input_flux_funcs</span><span class="p">()</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">input_fluxes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">external_input_flux_funcs</span><span class="p">()[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">input_fluxes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
        
        <span class="n">u</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">input_fluxes</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span> 
                                  <span class="k">if</span> <span class="n">t_valid</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span><span class="p">,)))</span>
        <span class="k">return</span> <span class="n">u</span></div>

    <span class="c1"># fixme: returns a vector</span>
<div class="viewcode-block" id="SmoothModelRun.output_rate_vector_at_t"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.output_rate_vector_at_t">[docs]</a>    <span class="k">def</span> <span class="nf">output_rate_vector_at_t</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a vector of output rates at time ``t``.</span>

<span class="sd">        Args:</span>
<span class="sd">            t (float): The time at which the output rates are computed.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.array: The ith entry contains the output rate of pool ``i`` </span>
<span class="sd">            at time ``t``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>

        <span class="n">sol_funcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sol_funcs</span><span class="p">()</span>
        <span class="n">output_vec_at_t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_vector_func</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

        <span class="n">rate_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,))</span>
        <span class="k">for</span> <span class="n">pool</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">sol_funcs</span><span class="p">[</span><span class="n">pool</span><span class="p">](</span><span class="n">t</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">rate_vec</span><span class="p">[</span><span class="n">pool</span><span class="p">]</span> <span class="o">=</span> <span class="n">output_vec_at_t</span><span class="p">[</span><span class="n">pool</span><span class="p">]</span> <span class="o">/</span> <span class="n">x</span>

        <span class="k">return</span> <span class="n">rate_vec</span></div>


    <span class="c1">##### fluxes as vector over self.times #####</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">external_input_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the grid of external input vectors.</span>

<span class="sd">        The input at time :math:`t_0` is set to zero by definition.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: len(times) x nr_pools</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flux_vector</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">external_inputs</span><span class="p">)</span>
        <span class="c1"># no inputs at t0 (only &gt;t0)</span>
        <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span><span class="p">,))</span>
        
        <span class="k">return</span> <span class="n">res</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">external_output_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the grid of external output vectors.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: len(times) x nr_pools</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_flux_vector</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">external_outputs</span><span class="p">))</span>

    <span class="nd">@property</span>    
    <span class="k">def</span> <span class="nf">output_rate_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the grid of output rate vectors.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: len(times) x nr_pools, ``solution/output_vector``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">soln</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
        <span class="n">output_vec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_output_vector</span>

        <span class="c1"># take care of possible division by zero</span>
        <span class="n">output_vec</span><span class="p">[</span><span class="n">soln</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">soln</span><span class="p">[</span><span class="n">soln</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="n">output_vec</span><span class="o">/</span><span class="n">soln</span>

    <span class="c1">##### age density methods #####</span>
    

<div class="viewcode-block" id="SmoothModelRun.pool_age_densities_single_value"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.pool_age_densities_single_value">[docs]</a>    <span class="k">def</span> <span class="nf">pool_age_densities_single_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_age_densities</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a function for the pool age densities.</span>

<span class="sd">        Args:</span>
<span class="sd">            start_age_densities (Python function, optional): A function of age </span>
<span class="sd">                that returns a numpy.array containing the masses with the given </span>
<span class="sd">                age at time :math:`t_0`. Defaults to None, meaning that all </span>
<span class="sd">                initial mass is considered to have zero age.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Python function ``p_sv``: ``p_sv(a, t)`` returns ``a numpy.array`` </span>
<span class="sd">            containing the pool contents with age ``a`` at time ``t``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p1_sv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_age_densities_1_single_value</span><span class="p">(</span><span class="n">start_age_densities</span><span class="p">)</span>
        <span class="n">p2_sv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_age_densities_2_single_value</span><span class="p">()</span>

        <span class="n">p_sv</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">p1_sv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">p2_sv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">p_sv</span></div>

    
    <span class="c1"># returns a function p that takes an age array &quot;ages&quot; as argument</span>
    <span class="c1"># and gives back a three-dimensional ndarray (ages x times x pools)</span>
    <span class="c1"># start_age_densities is a array-valued function of age</span>
<div class="viewcode-block" id="SmoothModelRun.pool_age_densities_func"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.pool_age_densities_func">[docs]</a>    <span class="k">def</span> <span class="nf">pool_age_densities_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_age_densities</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a function based on an age array that returns the </span>
<span class="sd">        pool age densities.</span>

<span class="sd">        Args:</span>
<span class="sd">            start_age_densities (Python function, optional): A function of age </span>
<span class="sd">                that returns a numpy.array containing the masses with the given </span>
<span class="sd">                age at time :math:`t_0`. </span>
<span class="sd">                Defaults to None, meaning that all initial mass is considered </span>
<span class="sd">                to have zero age.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            Python function ``p``: ``p(ages)`` returns a ``numpy.ndarray`` </span>
<span class="sd">            len(ages) x len(times) x nr_pools containing the pool contents </span>
<span class="sd">            with the respective ages at the respective times, where ``ages`` </span>
<span class="sd">            is a ``numpy.array``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_age_densities_1</span><span class="p">(</span><span class="n">start_age_densities</span><span class="p">)</span>
        <span class="n">p2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_age_densities_2</span><span class="p">()</span>
        
        <span class="k">def</span> <span class="nf">p</span><span class="p">(</span><span class="n">ages</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_computed_age_density_fields&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">((</span><span class="n">start_age_densities</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ages</span><span class="p">))</span> <span class="ow">in</span> 
                        <span class="bp">self</span><span class="o">.</span><span class="n">_computed_age_density_fields</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                    <span class="c1">#print(&#39;using cached result&#39;)</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_computed_age_density_fields</span><span class="p">[</span>
                                <span class="p">(</span><span class="n">start_age_densities</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ages</span><span class="p">))]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_computed_age_density_fields</span> <span class="o">=</span> <span class="p">{}</span>
        
            <span class="n">field_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">ages</span><span class="p">):</span>
                <span class="n">field_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p1</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="p">]))</span> <span class="o">+</span> <span class="n">p2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="p">])))</span>

            <span class="n">field</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">field_list</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">,:,:]</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">_computed_age_density_fields</span><span class="p">[</span>
                <span class="p">(</span><span class="n">start_age_densities</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ages</span><span class="p">))]</span> <span class="o">=</span> <span class="n">field</span>
            <span class="k">return</span> <span class="n">field</span>
                
        <span class="k">return</span> <span class="n">p</span></div>

    
<div class="viewcode-block" id="SmoothModelRun.system_age_density_single_value"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.system_age_density_single_value">[docs]</a>    <span class="k">def</span> <span class="nf">system_age_density_single_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_age_densities</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a function for the system age density.</span>

<span class="sd">        Args:</span>
<span class="sd">            start_age_densities (Python function, optional): A function of age </span>
<span class="sd">                that returns a numpy.array containing the masses with the given </span>
<span class="sd">                age at time :math:`t_0`. </span>
<span class="sd">                Defaults to None, meaning that all initial mass is considered </span>
<span class="sd">                to have zero age.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Python function ``sys_p_sv``: ``sys_p_sv(a, t)`` returns the system </span>
<span class="sd">            content with age ``a`` at time ``t``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p_sv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pool_age_densities_single_value</span><span class="p">(</span><span class="n">start_age_densities</span><span class="p">)</span>
        <span class="n">sys_p_sv</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span><span class="n">p_sv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">t</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">sys_p_sv</span></div>


    <span class="c1"># return array ages x times with ages based on pool_age_densities</span>
<div class="viewcode-block" id="SmoothModelRun.system_age_density"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.system_age_density">[docs]</a>    <span class="k">def</span> <span class="nf">system_age_density</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pool_age_densities</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the system age density based on the given pool age densities.</span>

<span class="sd">        Args:</span>
<span class="sd">            pool_age_densites (numpy.ndarray len(ages) x len(times) x nr_pools):</span>
<span class="sd">                The pool age density values.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: (len(ages) x len(times)) The sum of the pool age </span>
<span class="sd">            contents over all pools.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">pool_age_densities</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span></div>


    <span class="c1"># combine pool and system age densities to one numpy array</span>
<div class="viewcode-block" id="SmoothModelRun.age_densities"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.age_densities">[docs]</a>    <span class="k">def</span> <span class="nf">age_densities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pool_age_densities</span><span class="p">,</span> <span class="n">system_age_density</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Combine pool and system age densities to one numpy.array.</span>

<span class="sd">        Args:</span>
<span class="sd">            pool_age_densites (numpy.ndarray len(ages) x len(times) x nr_pools):</span>
<span class="sd">                The pool age density values.</span>
<span class="sd">            system_age_density (numpy.ndarray len(ages) x len(times)): </span>
<span class="sd">                The system age density values.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: (len(ages) x len(times) x (nr_pools+1)).</span>
<span class="sd">            The system age density values are appended to the end of the </span>
<span class="sd">            pool density values (system = pool ``d+1`` with ``d = nr_pools``).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>
        <span class="n">nr_ages</span> <span class="o">=</span> <span class="n">pool_age_densities</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">nr_times</span> <span class="o">=</span> <span class="n">pool_age_densities</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">_age_densities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nr_ages</span><span class="p">,</span> <span class="n">nr_times</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">_age_densities</span><span class="p">[:,:,:</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">pool_age_densities</span>
        <span class="n">_age_densities</span><span class="p">[:,:,</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">system_age_density</span>

        <span class="k">return</span> <span class="n">_age_densities</span></div>


    <span class="c1">##### age moment methods #####</span>


<div class="viewcode-block" id="SmoothModelRun.age_moment_vector_from_densities"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.age_moment_vector_from_densities">[docs]</a>    <span class="k">def</span> <span class="nf">age_moment_vector_from_densities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">start_age_densities</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the ``order`` th moment of the pool ages by integration.</span>

<span class="sd">        This function is extremely slow, since for each pool the integral over </span>
<span class="sd">        the density is computed based on the singe-valued functions. It is </span>
<span class="sd">        implemented only for the sake of completeness and to test the results </span>
<span class="sd">        obtained by faster methods.</span>

<span class="sd">        Args:</span>
<span class="sd">            order (int): The order of the moment to be computed.</span>
<span class="sd">            start_age_densities (Python function, optional): </span>
<span class="sd">                A function of age that returns a numpy.array containing the </span>
<span class="sd">                masses with the given age at time :math:`t_0`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: len(times) x nr_pools. </span>
<span class="sd">            Contains the ``order`` th moment </span>
<span class="sd">            of the pool ages over the time grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p_sv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pool_age_densities_single_value</span><span class="p">(</span><span class="n">start_age_densities</span><span class="p">)</span>
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">order</span>

        <span class="k">def</span> <span class="nf">am_at_time_index_for_pool</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span> <span class="n">pool</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">integrand</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="o">**</span><span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="n">p_sv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">times</span><span class="p">[</span><span class="n">ti</span><span class="p">])[</span><span class="n">pool</span><span class="p">]</span>
            
            <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="n">ti</span><span class="p">,</span> <span class="n">pool</span><span class="p">]</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">quad</span><span class="p">(</span><span class="n">integrand</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>        

        <span class="k">def</span> <span class="nf">age_moment_at_time_index</span><span class="p">(</span><span class="n">ti</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">am_at_time_index_for_pool</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span> <span class="n">pool</span><span class="p">)</span> 
                                <span class="k">for</span> <span class="n">pool</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)])</span>

        <span class="n">am_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">age_moment_at_time_index</span><span class="p">(</span><span class="n">ti</span><span class="p">)</span> 
                            <span class="k">for</span> <span class="n">ti</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">))])</span> 
        <span class="n">am</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">),</span> <span class="n">n</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">,</span> <span class="n">am_arr</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">am</span></div>


<div class="viewcode-block" id="SmoothModelRun.age_moment_vector_semi_explicit"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.age_moment_vector_semi_explicit">[docs]</a>    <span class="k">def</span> <span class="nf">age_moment_vector_semi_explicit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> 
                                        <span class="n">start_age_moments</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">times</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the ``order`` th moment of the pool ages by a semi-explicit </span>
<span class="sd">        formula.</span>

<span class="sd">        This function bases on a semi-explicit formula such that no improper </span>
<span class="sd">        integrals need to be computed.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            order (int): The order of the age moment to be computed.</span>
<span class="sd">            start_age_moments (numpy.ndarray order x nr_pools, optional): </span>
<span class="sd">                Given initial age moments up to the order of interest. </span>
<span class="sd">                Can possibly be computed by :func:`moments_from_densities`. </span>
<span class="sd">                Defaults to None assuming zero initial ages.</span>
<span class="sd">            times (numpy.array, optional): Time grid. </span>
<span class="sd">                Defaults to None and the original time grid is used.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: len(times) x nr_pools.</span>
<span class="sd">            The ``order`` th pool age moments over the time grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
            
        <span class="k">if</span> <span class="n">times</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
        <span class="n">t0</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">order</span>
        
        <span class="k">if</span> <span class="n">start_age_moments</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start_age_moments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">order</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>

        <span class="n">start_age_moments</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">start_age_moments</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">p2_sv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_age_densities_2_single_value</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">binomial</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">k</span><span class="o">==</span><span class="mi">0</span> <span class="k">else</span> <span class="p">(</span><span class="mi">0</span> <span class="k">if</span> <span class="n">n</span><span class="o">==</span><span class="mi">0</span> 
                                    <span class="k">else</span> <span class="n">binomial</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="n">binomial</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>

        <span class="n">Phi</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state_transition_operator</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">x0_a0_bar</span><span class="p">(</span><span class="n">j</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> 
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_values</span>
                
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start_values</span><span class="p">)</span> <span class="o">*</span> <span class="n">start_age_moments</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,:]</span>

        <span class="k">def</span> <span class="nf">both_parts_at_time</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">part2_time</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
                <span class="k">def</span> <span class="nf">part2_time_index_pool</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span> <span class="n">pool</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span><span class="o">**</span><span class="n">k</span> <span class="o">*</span> <span class="n">p2_sv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="p">)[</span><span class="n">pool</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="o">-</span><span class="n">t0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">part2_time_index_pool</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">pool</span><span class="p">)</span> 
                                    <span class="k">for</span> <span class="n">pool</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)])</span>

            <span class="k">def</span> <span class="nf">part1_time</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
                <span class="k">def</span> <span class="nf">summand</span><span class="p">(</span><span class="n">j</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">binomial</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="n">t0</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="n">Phi</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">x0_a0_bar</span><span class="p">(</span><span class="n">j</span><span class="p">))</span>

                <span class="k">return</span> <span class="nb">sum</span><span class="p">([</span><span class="n">summand</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span>

            <span class="k">return</span> <span class="n">part1_time</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">part2_time</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

        <span class="n">soln</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">both_parts_normalized_at_time_index</span><span class="p">(</span><span class="n">ti</span><span class="p">):</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="n">ti</span><span class="p">]</span>
            <span class="n">bp</span> <span class="o">=</span> <span class="n">both_parts_at_time</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="n">diag_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span> <span class="k">if</span> <span class="n">x</span><span class="o">&gt;</span><span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">soln</span><span class="p">[</span><span class="n">ti</span><span class="p">,:]])</span>
            <span class="n">X_inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">diag_values</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>

            <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mat</span><span class="p">(</span><span class="n">X_inv</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">mat</span><span class="p">(</span><span class="n">bp</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span><span class="o">.</span><span class="n">A1</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">both_parts_normalized_at_time_index</span><span class="p">(</span><span class="n">ti</span><span class="p">)</span> 
                            <span class="k">for</span> <span class="n">ti</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">))])</span></div>
        

<div class="viewcode-block" id="SmoothModelRun.age_moment_vector"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.age_moment_vector">[docs]</a>    <span class="k">def</span> <span class="nf">age_moment_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">start_age_moments</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the ``order`` th pool age moment vector over the time grid </span>
<span class="sd">        by an ODE system.</span>

<span class="sd">        This function solves an ODE system to obtain the pool age moments very</span>
<span class="sd">        fast. If the system has empty pools at the beginning, the semi-explicit </span>
<span class="sd">        formula is used until all pools are non-empty. Then the ODE system </span>
<span class="sd">        starts.</span>

<span class="sd">        Args:</span>
<span class="sd">            order (int): The order of the pool age moments to be computed.</span>
<span class="sd">            start_age_moments (numpy.ndarray order x nr_pools, optional): </span>
<span class="sd">                Given initial age moments up to the order of interest. </span>
<span class="sd">                Can possibly be computed by :func:`moments_from_densities`. </span>
<span class="sd">                Defaults to None assuming zero initial ages.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: len(times) x nr_pools.</span>
<span class="sd">            The ``order`` th pool age moments over the time grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
        
        <span class="k">if</span> <span class="n">start_age_moments</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start_age_moments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">order</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_values</span><span class="p">):</span>
            <span class="n">ams</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_solve_age_moment_system</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">start_age_moments</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">ams</span><span class="p">[:,</span><span class="n">n</span><span class="o">*</span><span class="n">order</span><span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># try to start adapted mean_age_system once no pool </span>
            <span class="c1"># has np.nan as mean_age (empty pool)</span>

            <span class="c1"># find last time index that contains an empty pool --&gt; ti</span>
            <span class="n">soln</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
            <span class="n">ti</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
            <span class="n">content</span> <span class="o">=</span> <span class="n">soln</span><span class="p">[</span><span class="n">ti</span><span class="p">,:]</span>
            <span class="k">while</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="ow">in</span> <span class="n">content</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">ti</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">):</span> 
                <span class="n">ti</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-</span><span class="mi">1</span>
                <span class="n">content</span> <span class="o">=</span> <span class="n">soln</span><span class="p">[</span><span class="n">ti</span><span class="p">,:]</span>

            <span class="c1"># not forever an empty pool there?</span>
            <span class="k">if</span> <span class="n">ti</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">):</span>
                <span class="c1"># compute moment with semi-explicit formula </span>
                <span class="c1"># as long as there is an empty pool</span>
                <span class="n">amv1_list</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">amv1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ti</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="n">order</span><span class="o">*</span><span class="n">n</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">order</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">amv1_k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">age_moment_vector_semi_explicit</span><span class="p">(</span>
                        <span class="n">k</span><span class="p">,</span> <span class="n">start_age_moments</span><span class="p">,</span> <span class="n">times</span><span class="p">[:</span><span class="n">ti</span><span class="o">+</span><span class="mi">2</span><span class="p">])</span>
                    <span class="n">amv1</span><span class="p">[:,(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">n</span><span class="p">:</span><span class="n">k</span><span class="o">*</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">amv1_k</span>

                <span class="c1"># use last values as start values for moment system </span>
                <span class="c1"># with nonzero start values</span>
                <span class="n">new_start_age_moments</span> <span class="o">=</span> <span class="n">amv1</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">order</span><span class="p">))</span>
                <span class="n">start_values</span> <span class="o">=</span> <span class="n">soln</span><span class="p">[</span><span class="n">ti</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">ams</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_solve_age_moment_system</span><span class="p">(</span>
                    <span class="n">order</span><span class="p">,</span> <span class="n">new_start_age_moments</span><span class="p">,</span> <span class="n">times</span><span class="p">[</span><span class="n">ti</span><span class="o">+</span><span class="mi">1</span><span class="p">:],</span> <span class="n">start_values</span><span class="p">)</span>
                <span class="n">amv2</span> <span class="o">=</span> <span class="n">ams</span><span class="p">[:,</span><span class="n">n</span><span class="o">*</span><span class="n">order</span><span class="p">:]</span>

                <span class="c1"># put the two parts together</span>
                <span class="n">part1</span> <span class="o">=</span> <span class="n">amv1</span><span class="p">[:,(</span><span class="n">order</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">n</span><span class="p">:</span><span class="n">order</span><span class="o">*</span><span class="n">n</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">amv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">),</span> <span class="n">n</span><span class="p">))</span>
                <span class="n">amv</span><span class="p">[:</span><span class="n">part1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:</span><span class="n">part1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">part1</span>
                <span class="n">amv</span><span class="p">[</span><span class="n">part1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:,</span> <span class="p">:</span><span class="n">amv2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">amv2</span>
                <span class="k">return</span> <span class="n">amv</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># always an empty pool there</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">age_moment_vector_semi_explicit</span><span class="p">(</span>
                        <span class="n">order</span><span class="p">,</span> <span class="n">start_age_moments</span><span class="p">)</span></div>


    <span class="c1"># requires start moments &lt;= order</span>
<div class="viewcode-block" id="SmoothModelRun.system_age_moment"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.system_age_moment">[docs]</a>    <span class="k">def</span> <span class="nf">system_age_moment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">start_age_moments</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the ``order`` th system age moment vector over the time grid </span>
<span class="sd">        by an ODE system.</span>

<span class="sd">        The pool age moments are computed by :func:`age_moment_vector` and then </span>
<span class="sd">        weighted corresponding to the pool contents.</span>

<span class="sd">        Args:</span>
<span class="sd">            order (int): The order of the pool age moments to be computed.</span>
<span class="sd">            start_age_moments (numpy.ndarray order x nr_pools, optional): </span>
<span class="sd">                Given initial age moments up to the order of interest. </span>
<span class="sd">                Can possibly be computed by :func:`moments_from_densities`. </span>
<span class="sd">                Defaults to None assuming zero initial ages.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.array: The ``order`` th system age moment over the time grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>
        <span class="n">age_moment_vector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">age_moment_vector</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">start_age_moments</span><span class="p">)</span>
        <span class="n">age_moment_vector</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">age_moment_vector</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">soln</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
         
        <span class="n">total_mass</span> <span class="o">=</span> <span class="n">soln</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># row sum</span>
        <span class="n">total_mass</span><span class="p">[</span><span class="n">total_mass</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="n">system_age_moment</span> <span class="o">=</span> <span class="p">(</span><span class="n">age_moment_vector</span><span class="o">*</span><span class="n">soln</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">total_mass</span>

        <span class="k">return</span> <span class="n">system_age_moment</span></div>
        

    <span class="c1">##### transit time density methods #####</span>


<div class="viewcode-block" id="SmoothModelRun.backward_transit_time_density_single_value"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.backward_transit_time_density_single_value">[docs]</a>    <span class="k">def</span> <span class="nf">backward_transit_time_density_single_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_age_densities</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a function that returns a single value for the </span>
<span class="sd">        backward transit time density.</span>

<span class="sd">        Args:</span>
<span class="sd">            start_age_densities (Python function, optional): </span>
<span class="sd">                A function of age that returns a numpy.array containing the </span>
<span class="sd">                masses with the given age at time :math:`t_0`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Python function ``p_sv``: ``p_sv(a, t)`` returns the mass that </span>
<span class="sd">            leaves the system at time ``t`` with age ``a``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>
        <span class="n">p_age_sv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pool_age_densities_single_value</span><span class="p">(</span><span class="n">start_age_densities</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">p_sv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">p_age_sv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
            <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_rate_vector_at_t</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> 
            
        <span class="k">return</span> <span class="n">p_sv</span></div>


    <span class="c1"># return an array ages x times with ages based on pool_age_densities</span>
<div class="viewcode-block" id="SmoothModelRun.backward_transit_time_density"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.backward_transit_time_density">[docs]</a>    <span class="k">def</span> <span class="nf">backward_transit_time_density</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pool_age_densities</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the backward transit time based on given pool age densities.</span>

<span class="sd">        The result is obtained by computing a weighted sum of the pool age </span>
<span class="sd">        densities according to output rates.</span>

<span class="sd">        Args:</span>
<span class="sd">            pool_age_densites (numpy.ndarray len(ages) x len(times) x nr_pools):</span>
<span class="sd">                The pool age density values.</span>
<span class="sd">    </span>
<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: len(ages) x len(times). Mass leaving the system with </span>
<span class="sd">            the respective age at the respective time.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_rate_vector</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">pool_age_densities</span><span class="o">*</span><span class="n">r</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="SmoothModelRun.forward_transit_time_density_single_value"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.forward_transit_time_density_single_value">[docs]</a>    <span class="k">def</span> <span class="nf">forward_transit_time_density_single_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cut_off</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a function that returns a single value for the </span>
<span class="sd">        forward transit time density.</span>

<span class="sd">        Args:</span>
<span class="sd">            cut_off (bool, optional): If True, no density values are going to </span>
<span class="sd">                be computed after the end of the time grid, instead numpy.nan </span>
<span class="sd">                will be returned. </span>
<span class="sd">                Defaults to True and False might lead to unexpected behavior.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            Python function ``p_sv``: ``p_sv(a, t)`` returns how much mass will </span>
<span class="sd">            leave the system with age ``a`` when it came in at time ``t``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
        <span class="n">Phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state_transition_operator</span>
        <span class="n">input_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_input_vector_func</span><span class="p">()</span>
        <span class="n">t0</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>   
        <span class="n">t_max</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> 
        <span class="k">def</span> <span class="nf">p_ftt_sv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
            <span class="c1">#print(a,t)</span>
            <span class="c1"># nothing leaves before t0</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">t0</span><span class="p">):</span> <span class="k">return</span> <span class="mi">0</span>

            <span class="c1">#fixme: for MH we might need the density ver far away...</span>
            <span class="c1"># we cannot compute the density if t+a is out of bounds</span>
            <span class="k">if</span> <span class="n">cut_off</span> <span class="ow">and</span> <span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">t_max</span><span class="p">):</span> <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

            <span class="n">u</span> <span class="o">=</span> <span class="n">input_func</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span> <span class="k">return</span> <span class="mf">0.0</span>
            
            <span class="k">return</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Phi</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">p_ftt_sv</span></div>


    <span class="c1">#fixme: return value not consistent with backward_transit_time_density</span>
    <span class="c1"># not that easy to resolve, since here we do not use age_densities,</span>
    <span class="c1"># instead ages is really needed to be able to make the shift or call </span>
    <span class="c1"># the state_transition_operator</span>
<div class="viewcode-block" id="SmoothModelRun.forward_transit_time_density_func"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.forward_transit_time_density_func">[docs]</a>    <span class="k">def</span> <span class="nf">forward_transit_time_density_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cut_off</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a function based on an age array for the forward transit time </span>
<span class="sd">        density.</span>

<span class="sd">        Args:</span>
<span class="sd">            cut_off (bool, optional): If True, no density values are going to </span>
<span class="sd">                be computed after the end of the time grid, instead numpy.nan </span>
<span class="sd">                will be returned. </span>
<span class="sd">                Defaults to True and False might lead to unexpected behavior.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            Python function ``p``: ``p(ages)`` is a ``numpy.ndarray`` </span>
<span class="sd">            len(ages) x len(times) that gives the mass that will leave the</span>
<span class="sd">            system with the respective age when it came in at time ``t``, </span>
<span class="sd">            where ``ages`` is a ``numpy.array``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p_sv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward_transit_time_density_single_value</span><span class="p">(</span><span class="n">cut_off</span><span class="p">)</span>
        <span class="n">pp</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">p_sv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="c1">#p = lambda ages: np.array([pp(a) for a in ages], np.float)</span>
        <span class="k">def</span> <span class="nf">p</span><span class="p">(</span><span class="n">ages</span><span class="p">):</span>
            <span class="n">field_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">ages</span><span class="p">):</span>
                <span class="n">field_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pp</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>

            <span class="n">field</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">field_list</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">field</span>

        <span class="k">return</span> <span class="n">p</span></div>


    <span class="c1">##### transit time moment methods #####</span>

    
<div class="viewcode-block" id="SmoothModelRun.backward_transit_time_moment_from_density"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.backward_transit_time_moment_from_density">[docs]</a>    <span class="k">def</span> <span class="nf">backward_transit_time_moment_from_density</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
            <span class="n">order</span><span class="p">,</span> <span class="n">start_age_densities</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the ``order`` th backward transit time moment based on an </span>
<span class="sd">        improper integral over the density.</span>

<span class="sd">        This function is extremely slow and implemented only for the sake of </span>
<span class="sd">        completeness and for testing results from faster approaches.</span>

<span class="sd">        Args:</span>
<span class="sd">            order (int): The order of the backward transit time moment that is </span>
<span class="sd">                to be computed.</span>
<span class="sd">            start_age_densities (Python function, optional): A function of age </span>
<span class="sd">                that returns a numpy.array containing the masses with the given </span>
<span class="sd">                age at time :math:`t_0`.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            numpy.array: The ``order`` th backward transit time moment over the </span>
<span class="sd">            time grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p_sv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">backward_transit_time_density_single_value</span><span class="p">(</span>
                    <span class="n">start_age_densities</span><span class="p">)</span>
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">order</span>

        <span class="n">ext_outp_vec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_output_vector</span>
        <span class="n">ext_outp</span> <span class="o">=</span> <span class="n">ext_outp_vec</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
     
        <span class="k">def</span> <span class="nf">btt_moment_at_time_index</span><span class="p">(</span><span class="n">ti</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">integrand</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="o">**</span><span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="n">p_sv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">times</span><span class="p">[</span><span class="n">ti</span><span class="p">])</span>
            
            <span class="k">return</span> <span class="n">ext_outp</span><span class="p">[</span><span class="n">ti</span><span class="p">]</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">quad</span><span class="p">(</span><span class="n">integrand</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>        

        <span class="n">bttm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">btt_moment_at_time_index</span><span class="p">(</span><span class="n">ti</span><span class="p">)</span> 
                            <span class="k">for</span> <span class="n">ti</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">))])</span> 
        <span class="k">return</span> <span class="n">bttm</span></div>


<div class="viewcode-block" id="SmoothModelRun.backward_transit_time_moment"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.backward_transit_time_moment">[docs]</a>    <span class="k">def</span> <span class="nf">backward_transit_time_moment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">start_age_moments</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the ``order`` th backward transit time moment based on the </span>
<span class="sd">        :func:`age_moment_vector`.</span>

<span class="sd">        Args:</span>
<span class="sd">            order (int): The order of the backward transit time moment that is </span>
<span class="sd">                to be computed.</span>
<span class="sd">            start_age_moments (numpy.ndarray order x nr_pools, optional): </span>
<span class="sd">                Given initial age moments up to the order of interest. </span>
<span class="sd">                Can possibly be computed by :func:`moments_from_densities`. </span>
<span class="sd">                Defaults to None assuming zero initial ages.</span>
<span class="sd">       </span>
<span class="sd">        Returns:</span>
<span class="sd">            numpy.array: The ``order`` th backward transit time moment over the </span>
<span class="sd">            time grid.</span>
<span class="sd">        &quot;&quot;&quot;</span> 
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>

        <span class="n">age_moment_vector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">age_moment_vector</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">start_age_moments</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_output_vector</span>
        
        <span class="k">return</span> <span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">age_moment_vector</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">r</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="SmoothModelRun.forward_transit_time_moment"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.forward_transit_time_moment">[docs]</a>    <span class="k">def</span> <span class="nf">forward_transit_time_moment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the ``order`` th forward transit time moment.</span>

<span class="sd">        Attention! This function integrates over the state transition operator </span>
<span class="sd">        until infinite time.</span>
<span class="sd">        The results are going to be weird, since at the end of the time grid </span>
<span class="sd">        some cut- off will happen which biases the result.</span>

<span class="sd">        Args:</span>
<span class="sd">            order (int): The order of the forward transit time moment to be </span>
<span class="sd">                computed.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.array: The ``order`` th forward transit time moment over the </span>
<span class="sd">            time grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">order</span>
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
        <span class="n">Phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state_transition_operator</span>
        <span class="n">input_vector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_input_vector</span>

        <span class="c1">#import warnings</span>
        <span class="c1">#from scipy.integrate import IntegrationWarning</span>
        <span class="c1">#warnings.simplefilter(&quot;error&quot;, IntegrationWarning)</span>
        <span class="k">def</span> <span class="nf">moment_at_ti</span><span class="p">(</span><span class="n">ti</span><span class="p">):</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">input_vector</span><span class="p">[</span><span class="n">ti</span><span class="p">]</span> 
            
            <span class="c1"># if we have no inputs, there cannot be a transit(time)</span>
            <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>    
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

            <span class="k">def</span> <span class="nf">integrand</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
                <span class="n">res</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="n">a</span><span class="o">**</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">Phi</span><span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="n">ti</span><span class="p">]</span><span class="o">+</span><span class="n">a</span><span class="p">,</span> <span class="n">times</span><span class="p">[</span><span class="n">ti</span><span class="p">],</span> <span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span><span class="o">/</span><span class="n">u</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                <span class="c1">#print(a, Phi(times[ti]+a, times[ti], u), res)</span>
                <span class="k">return</span> <span class="n">res</span>

            <span class="c1"># fixme:</span>
            <span class="c1"># it is possible that quad can be replaced by something</span>
            <span class="c1"># that is better suited for the infinite integration domain</span>
            <span class="c1"># that is always required for forward transit times.</span>
            <span class="c1">#print(times[ti], &#39;\n&#39;)</span>
            <span class="k">return</span> <span class="n">quad</span><span class="p">(</span><span class="n">integrand</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">infty</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">moment_at_ti</span><span class="p">(</span><span class="n">ti</span><span class="p">)</span> <span class="k">for</span> <span class="n">ti</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">))])</span>
        <span class="k">return</span> <span class="n">res</span></div>


    <span class="c1">#fixme: split into two functions for SCCS and MH</span>
    <span class="c1"># do not use dict as default value</span>
<div class="viewcode-block" id="SmoothModelRun.apply_to_forward_transit_time_simulation"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.apply_to_forward_transit_time_simulation">[docs]</a>    <span class="k">def</span> <span class="nf">apply_to_forward_transit_time_simulation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
            <span class="n">f_dict</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;mean&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">},</span> <span class="n">N</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">MH</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This is just a tentative approach.</span>

<span class="sd">        To be honest, the problem of an unkown infinite future cannot be solved </span>
<span class="sd">        this way, since the densities used to simulate forward transit time </span>
<span class="sd">        random variables are biased by the cut-off at the end of the time grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># f is a Python function, for the mean, take f = np.mean</span>
        <span class="c1"># N is the number of simulations per each time step</span>
        <span class="c1"># M is the number of collocation points for </span>
        <span class="c1"># stochastic collocation sampling</span>
        <span class="c1"># allowed values for M are 2, 3, 4, ..., 11</span>
        <span class="c1"># other values lead to inverse transform sampling (slow)</span>
        <span class="c1"># k is the order of the smoothing and interpolating spline</span>
        <span class="c1"># &#39;smoothing_spline&#39; is best used for inverse transform sampling, </span>
        <span class="c1"># because of additional smoothing for low</span>
        <span class="c1"># number of random variates</span>
        <span class="c1"># for SCMCS (M in [2,...,11]), &#39;interpolation&#39; is better, </span>
        <span class="c1"># because the higher number of random variates </span>
        <span class="c1"># (because of faster sampling) makes their mean already quite precise </span>
        <span class="c1"># (in the framework of what is possible with SCMCS)</span>
  
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
        <span class="n">Phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state_transition_operator</span>
        <span class="n">input_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_input_vector_func</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">MH</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">def</span> <span class="nf">F_FTT</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">input_func</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> 
                    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                
                <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span> <span class="k">return</span> <span class="mf">0.0</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">Phi</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">/</span><span class="n">u</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    
            
            <span class="k">def</span> <span class="nf">simulate</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">CDF</span><span class="p">):</span>
                <span class="c1"># compute lagrange polynomial p if M is in [2, ..., 11]</span>
                <span class="n">g</span> <span class="o">=</span> <span class="n">stochastic_collocation_transform</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">CDF</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">g</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> 
                    <span class="c1"># inverse transform sampling</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;inverse transform sampling&#39;</span><span class="p">)</span>
                    <span class="n">rvs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">draw_rv</span><span class="p">(</span><span class="n">CDF</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">norms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span> <span class="o">=</span> <span class="n">n</span><span class="p">)</span>
                    <span class="n">rvs</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">norms</span><span class="p">)</span>
        
                <span class="k">return</span> <span class="n">rvs</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">p_sv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward_transit_time_density_single_value</span><span class="p">(</span><span class="n">cut_off</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">def</span> <span class="nf">f_FTT</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">return</span> <span class="n">p_sv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>


        <span class="n">res</span> <span class="o">=</span> <span class="p">{</span><span class="n">f_name</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;values&#39;</span><span class="p">:</span> <span class="p">[],</span> 
                        <span class="s1">&#39;smoothing_spline&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> 
                        <span class="s1">&#39;interpolation&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">}</span> <span class="k">for</span> <span class="n">f_name</span> <span class="ow">in</span> <span class="n">f_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">times</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
            <span class="c1"># no iput means no forward transit time</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">input_func</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> 
                <span class="n">rvs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">MH</span><span class="p">:</span>
                    <span class="n">rvs</span> <span class="o">=</span> <span class="n">simulate</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">F_FTT</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span>
                    <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="s1">&#39;calls of state transition operator&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">rvs</span> <span class="o">=</span> <span class="n">MH_sampling</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">f_FTT</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span>
                    <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="s1">&#39;calls of forward transit time density&#39;</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">f_name</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">f_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">rvs</span><span class="p">)</span>
                <span class="n">res</span><span class="p">[</span><span class="n">f_name</span><span class="p">][</span><span class="s1">&#39;values&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">f_name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                
        <span class="k">for</span> <span class="n">f_name</span> <span class="ow">in</span> <span class="n">res</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">f_name</span><span class="p">][</span><span class="s1">&#39;values&#39;</span><span class="p">])</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">res</span><span class="p">[</span><span class="n">f_name</span><span class="p">][</span><span class="s1">&#39;values&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="c1"># give weight zero to nan values fo compting the spline</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
            <span class="n">y</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="n">res</span><span class="p">[</span><span class="n">f_name</span><span class="p">][</span><span class="s1">&#39;smoothing_spline&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">UnivariateSpline</span><span class="p">(</span>
                <span class="n">times</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">w</span><span class="o">=~</span><span class="n">w</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">res</span><span class="p">[</span><span class="n">f_name</span><span class="p">][</span><span class="s1">&#39;interpolation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="o">~</span><span class="n">w</span><span class="p">],</span> <span class="n">z</span><span class="p">[</span><span class="o">~</span><span class="n">w</span><span class="p">],</span> <span class="n">kind</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span></div>

    <span class="c1"># use inverse transform sampling</span>
<div class="viewcode-block" id="SmoothModelRun.apply_to_forward_transit_time_simulation_its"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.apply_to_forward_transit_time_simulation_its">[docs]</a>    <span class="k">def</span> <span class="nf">apply_to_forward_transit_time_simulation_its</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
            <span class="n">f_dict</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This is just a tentative approach.</span>

<span class="sd">        To be honest, the problem of an unkown infinite future cannot be solved </span>
<span class="sd">        this way, since the densities used to simulate forward transit time </span>
<span class="sd">        random variables are biased by the cut-off at the end of the time grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># f is a Python function, for the mean, take f = np.mean</span>
        <span class="c1"># N is the number of simulations per each time step</span>
        <span class="c1"># times is an np.array of interpolation points</span>
        <span class="c1"># k is the order of the smoothing and interpolating spline</span>
        <span class="c1"># &#39;smoothing_spline&#39; is best used for inverse transform sampling, </span>
        <span class="c1"># because of additional smoothing for low</span>
        <span class="c1"># number of random variates</span>
  
        <span class="n">Phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state_transition_operator</span>
        <span class="n">input_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_input_vector_func</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">F_FTT</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">input_func</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> 
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            
            <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span> <span class="k">return</span> <span class="mf">0.0</span>

            <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">Phi</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">/</span><span class="n">u</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="n">res</span> <span class="o">=</span> <span class="p">{</span><span class="n">f_name</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;values&#39;</span><span class="p">:</span> <span class="p">[],</span> 
                        <span class="s1">&#39;smoothing_spline&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> 
                        <span class="s1">&#39;interpolation&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">}</span> <span class="k">for</span> <span class="n">f_name</span> <span class="ow">in</span> <span class="n">f_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">times</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
            <span class="c1"># no iput means no forward transit time</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">input_func</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> 
                <span class="n">rvs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">CDF</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">F_FTT</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
                <span class="n">rvs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">draw_rv</span><span class="p">(</span><span class="n">CDF</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)])</span>

            <span class="k">for</span> <span class="n">f_name</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">f_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">rvs</span><span class="p">)</span>
                <span class="n">res</span><span class="p">[</span><span class="n">f_name</span><span class="p">][</span><span class="s1">&#39;values&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">f_name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                
        <span class="k">def</span> <span class="nf">compute_splines</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">times</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">f_name</span> <span class="ow">in</span> <span class="n">res</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">f_name</span><span class="p">][</span><span class="s1">&#39;values&#39;</span><span class="p">])</span>
                <span class="n">z</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">res</span><span class="p">[</span><span class="n">f_name</span><span class="p">][</span><span class="s1">&#39;values&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

                <span class="c1"># give weight zero to nan values fo compting the spline</span>
                <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
                <span class="n">y</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
                <span class="n">res</span><span class="p">[</span><span class="n">f_name</span><span class="p">][</span><span class="s1">&#39;smoothing_spline&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">UnivariateSpline</span><span class="p">(</span>
                    <span class="n">times</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">w</span><span class="o">=~</span><span class="n">w</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">res</span><span class="p">[</span><span class="n">f_name</span><span class="p">][</span><span class="s1">&#39;interpolation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="o">~</span><span class="n">w</span><span class="p">],</span><span class="n">z</span><span class="p">[</span><span class="o">~</span><span class="n">w</span><span class="p">],</span><span class="n">kind</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">res</span>

        <span class="k">return</span> <span class="n">compute_splines</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">times</span><span class="p">)</span></div>


    <span class="c1">##### comma separated values output methods #####</span>


<div class="viewcode-block" id="SmoothModelRun.save_pools_and_system_density_csv"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.save_pools_and_system_density_csv">[docs]</a>    <span class="k">def</span> <span class="nf">save_pools_and_system_density_csv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">pool_age_densities</span><span class="p">,</span> 
            <span class="n">system_age_density</span><span class="p">,</span> <span class="n">ages</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Save the pool and system age densities to a csv file.</span>

<span class="sd">        The system value will be coded into pool number -1.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            filename (str): The name of the csv file to be written.</span>
<span class="sd">            pool_age_densites (numpy.ndarray len(ages) x len(times) x nr_pools):</span>
<span class="sd">                The pool age density values.</span>
<span class="sd">            system_age_density (numpy.ndarray len(ages) x len(times)): </span>
<span class="sd">                The system age density values.</span>
<span class="sd">            ages (numpy.array): The ages that correspond to the indices in the</span>
<span class="sd">                zeroth dimension of the density arrays.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
    
        <span class="n">ndarr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">system_age_density</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">),</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">ndarr</span><span class="p">[:,:,:</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">pool_age_densities</span>
        <span class="n">ndarr</span><span class="p">[:,:,</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">system_age_density</span>

        <span class="n">pool_entries</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">melted</span> <span class="o">=</span> <span class="n">melt</span><span class="p">(</span><span class="n">ndarr</span><span class="p">,</span> <span class="p">[</span><span class="n">ages</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">pool_entries</span><span class="p">])</span>
        <span class="n">header</span> <span class="o">=</span> <span class="s1">&#39;&quot;age&quot;, &quot;time&quot;, &quot;pool&quot;, &quot;value&quot;&#39;</span>
        <span class="n">save_csv</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">melted</span><span class="p">,</span> <span class="n">header</span><span class="p">)</span></div>


<div class="viewcode-block" id="SmoothModelRun.save_pools_and_system_value_csv"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.save_pools_and_system_value_csv">[docs]</a>    <span class="k">def</span> <span class="nf">save_pools_and_system_value_csv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">pools_ndarr</span><span class="p">,</span> 
            <span class="n">system_arr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Save pool and system values to a csv file.</span>

<span class="sd">        Values could be the mean age, for example. One dimension less than a</span>
<span class="sd">        density.</span>
<span class="sd">        The system value will be coded into pool number -1.</span>

<span class="sd">        Args:</span>
<span class="sd">            filename (str): The name of the csv file to be written.</span>
<span class="sd">            pools_ndarr (numpy.ndarray len(times) x nr_pools): The values to be</span>
<span class="sd">                saved over the time-pool grid.</span>
<span class="sd">            system_arr (numpy.array): The values over the time grid </span>
<span class="sd">                corresponding to the system.</span>
<span class="sd">    </span>
<span class="sd">        Returns:</span>
<span class="sd">            None:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
    
        <span class="n">ndarr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">(</span><span class="n">pools_ndarr</span><span class="p">,</span> <span class="n">system_arr</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">),</span> <span class="mi">1</span><span class="p">))),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">pool_entries</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">melted</span> <span class="o">=</span> <span class="n">melt</span><span class="p">(</span><span class="n">ndarr</span><span class="p">,</span> <span class="p">[</span><span class="n">times</span><span class="p">,</span> <span class="n">pool_entries</span><span class="p">])</span>
        <span class="n">header</span> <span class="o">=</span> <span class="s1">&#39;&quot;time&quot;, &quot;pool&quot;, &quot;value&quot;&#39;</span>
        <span class="n">save_csv</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">melted</span><span class="p">,</span> <span class="n">header</span><span class="p">)</span></div>


    <span class="c1">## helping methods ##</span>

<div class="viewcode-block" id="SmoothModelRun.density_values_for_pools"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.density_values_for_pools">[docs]</a>    <span class="k">def</span> <span class="nf">density_values_for_pools</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pool_densities_sv</span><span class="p">,</span> <span class="n">pool_age_values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the pool age densities over the time grid at ages given in </span>
<span class="sd">        pool_age_values.</span>

<span class="sd">        This function can be used to obtain the density values at mean or median</span>
<span class="sd">        values to draw a curve on top of the density surface. But actually this</span>
<span class="sd">        is now implemented in a much faster way based on the surface itself.</span>

<span class="sd">        Args:</span>
<span class="sd">            pool_age_densites_sv (Python function): A function that takes </span>
<span class="sd">                ``a``, ``t`` as arguments and returns a vector of pool contents </span>
<span class="sd">                with mass a at time t. Potentially coming from </span>
<span class="sd">                :func:`pool_age_densities_single_value`.</span>
<span class="sd">            pool_age_values (numpy.ndarray len(times) x nr_pools): The ages over</span>
<span class="sd">                the time-pool grid at which the density values are to be </span>
<span class="sd">                computed.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: (len(times) x nr_pools) The pool density values over</span>
<span class="sd">            the time-pool grid based on the given age values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
    
        <span class="c1"># for each pool we have a different age value </span>
        <span class="n">z</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">pool</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">pool_age_values</span><span class="p">[:,</span><span class="n">pool</span><span class="p">]</span>
            <span class="c1">#z.append(np.array([pool_densities_sv(val[i], times[i])[pool] </span>
            <span class="c1">#                        for i in range(len(times))]))</span>
            <span class="n">new_z_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">))):</span>
                <span class="n">new_z_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pool_densities_sv</span><span class="p">(</span><span class="n">val</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">times</span><span class="p">[</span><span class="n">i</span><span class="p">])[</span><span class="n">pool</span><span class="p">])</span>

            <span class="n">z</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_z_list</span><span class="p">))</span>

            <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="k">return</span> <span class="n">z</span></div>

    <span class="c1"># return density values for mean, median, etc.</span>
    <span class="c1">#fixme: test</span>
<div class="viewcode-block" id="SmoothModelRun.density_values"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.density_values">[docs]</a>    <span class="k">def</span> <span class="nf">density_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">density_sv</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the density value over the time grid at ages given in values.</span>

<span class="sd">        This function can be used to obtain the density values at mean or median</span>
<span class="sd">        values to draw a curve on top of the density surface. But actually this</span>
<span class="sd">        is now implemented in a much faster way based on the surface itself.</span>

<span class="sd">        Args:</span>
<span class="sd">            density_sv (Python function): A function that takes ``a``, ``t`` </span>
<span class="sd">                as arguments and returns density value with age a at time ``t``.</span>
<span class="sd">                Potentially coming from :func:`system_age_density_single_value`.</span>
<span class="sd">            values (numpy.array): The ages over the time grid at which the </span>
<span class="sd">                density values are to be computed.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.array: The density values over the time grid based </span>
<span class="sd">            on the given age values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
        <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span> <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">return</span> <span class="n">density_sv</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">times</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="c1">#dv_list = [f(i) for i in range(len(times))]</span>

        <span class="n">dv_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">))):</span>
            <span class="n">dv_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dv_list</span><span class="p">)</span></div>


<div class="viewcode-block" id="SmoothModelRun.save_value_csv"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.save_value_csv">[docs]</a>    <span class="k">def</span> <span class="nf">save_value_csv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">arr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Save values over the time grid to a csv file.</span>

<span class="sd">        Args:</span>
<span class="sd">            filename (str): The name of the csv file to be written.</span>
<span class="sd">            arr (numpy.array): The values to be saved over the time grid.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">melted</span> <span class="o">=</span> <span class="n">melt</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">])</span>
        <span class="n">header</span> <span class="o">=</span> <span class="s1">&#39;&quot;time&quot;, &quot;value&quot;&#39;</span>
        <span class="n">save_csv</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">melted</span><span class="p">,</span> <span class="n">header</span><span class="p">)</span></div>

<div class="viewcode-block" id="SmoothModelRun.save_density_csv"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.save_density_csv">[docs]</a>    <span class="k">def</span> <span class="nf">save_density_csv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">density</span><span class="p">,</span> <span class="n">ages</span><span class="p">,</span> <span class="n">times</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Save density values over age-time grid to csv file.</span>

<span class="sd">        Args:</span>
<span class="sd">            filename (str): The name of the csv file to be written.</span>
<span class="sd">            density (numpy.ndarray len(ages) x len(times)): The density values</span>
<span class="sd">                to be saved over the age-time grid.</span>
<span class="sd">            ages (numpy.array): The ages corresponding to the indices in the</span>
<span class="sd">                zeroth dimension of the density ndarray.</span>
<span class="sd">            times (numpy.array, optional): An alternative time grid to be used.</span>
<span class="sd">                Defaults to None which means that the original time grid is </span>
<span class="sd">                going to be used.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">times</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
        <span class="n">melted</span> <span class="o">=</span> <span class="n">melt</span><span class="p">(</span><span class="n">density</span><span class="p">,</span> <span class="p">[</span><span class="n">ages</span><span class="p">,</span> <span class="n">times</span><span class="p">])</span>
        <span class="n">header</span> <span class="o">=</span> <span class="s1">&#39;&quot;age&quot;, &quot;time&quot;, &quot;value&quot;&#39;</span>
        <span class="n">save_csv</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">melted</span><span class="p">,</span> <span class="n">header</span><span class="p">)</span></div>
        

    <span class="c1">##### comma separated values input methods #####</span>


    <span class="c1">## combining pool and system structures ##</span>


<div class="viewcode-block" id="SmoothModelRun.combine_pools_and_system_values"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.combine_pools_and_system_values">[docs]</a>    <span class="k">def</span> <span class="nf">combine_pools_and_system_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pools_values</span><span class="p">,</span> <span class="n">system_values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Append the system values to the pool values as if they belonged to </span>
<span class="sd">        another pool.</span>

<span class="sd">        Args:</span>
<span class="sd">            pools_values (numpy.ndarray len(times) x nr_pools): The values to be</span>
<span class="sd">                saved over the time-pool grid.</span>
<span class="sd">            system_values (numpy.array): The system values to be saved over the</span>
<span class="sd">                time grid.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: len(times) x (nr_pools+1) The pool and system values</span>
<span class="sd">            over the time-pool grid with the system added at the end as another</span>
<span class="sd">            pool.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">),</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">values</span><span class="p">[:,:</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">pools_values</span>
        <span class="n">values</span><span class="p">[:,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">system_values</span>
    
        <span class="k">return</span> <span class="n">values</span></div>


    <span class="c1">## age ##</span>

    
<div class="viewcode-block" id="SmoothModelRun.load_pools_and_system_densities_csv"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.load_pools_and_system_densities_csv">[docs]</a>    <span class="k">def</span> <span class="nf">load_pools_and_system_densities_csv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">ages</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load pool and system age densities from a csv file.</span>

<span class="sd">        Attention: It is assumed that the data were saved before with the very </span>
<span class="sd">        same ages, times, and pools.</span>
<span class="sd">        Furthermore, it is assumed that the system value always follows the </span>
<span class="sd">        pool values.</span>

<span class="sd">        Args:</span>
<span class="sd">            filename (str): The csv file from which the data are to be read.</span>
<span class="sd">            ages (numpy.array): The ages corresponding to the age indices. </span>
<span class="sd">                What is needed here is in fact only the length of the age grid.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: len(ages) x len(times) x (nr_pools+1) The density </span>
<span class="sd">            values for the pools and the system over the </span>
<span class="sd">            ages-times-(pools+system) grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">melted</span> <span class="o">=</span> <span class="n">load_csv</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">ages</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">),</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> 
                            <span class="n">buffer</span><span class="o">=</span><span class="p">(</span><span class="n">melted</span><span class="p">[:,</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span></div>

<div class="viewcode-block" id="SmoothModelRun.load_density_csv"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.load_density_csv">[docs]</a>    <span class="k">def</span> <span class="nf">load_density_csv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">ages</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load density values from a csv file.</span>

<span class="sd">        Attention: It is assumed that the data were saved before with the very</span>
<span class="sd">        same ages, times, and pools.</span>

<span class="sd">        Args:</span>
<span class="sd">            filename (str): The csv file from which the data are to be read.</span>
<span class="sd">            ages (numpy.array): The ages corresponding to the age indices. </span>
<span class="sd">                What is needed here is in fact only the length of the age grid.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: len(ages) x len(times) The density values over the </span>
<span class="sd">            ages-times grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">melted</span> <span class="o">=</span> <span class="n">load_csv</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">ages</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">)),</span> 
                            <span class="n">buffer</span><span class="o">=</span><span class="p">(</span><span class="n">melted</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span></div>

<div class="viewcode-block" id="SmoothModelRun.load_pools_and_system_value_csv"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.load_pools_and_system_value_csv">[docs]</a>    <span class="k">def</span> <span class="nf">load_pools_and_system_value_csv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load pool and system values from a csv file.</span>

<span class="sd">        Values could be the mean/median age, for example. One dimension less </span>
<span class="sd">        than a density.</span>

<span class="sd">        Attention: It is assumed that the data were saved before with the very</span>
<span class="sd">        same ages, times, and pools.</span>
<span class="sd">        Furthermore, it is assumed that the system value always follows the </span>
<span class="sd">        pool values.</span>

<span class="sd">        Args:</span>
<span class="sd">            filename (str): The csv file from which the data are to be read.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: len(times) x (nr_pools+1) The values for the pools </span>
<span class="sd">            and the system over the times-(pools+system) grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">melted</span> <span class="o">=</span> <span class="n">load_csv</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>
        <span class="n">values_lst</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">pool</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">melted</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">pool</span>
            <span class="n">values_lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">melted</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">indices</span><span class="p">),</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">pool_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">values_lst</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

        <span class="n">indices</span> <span class="o">=</span> <span class="n">melted</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">system_values</span> <span class="o">=</span> <span class="n">melted</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">indices</span><span class="p">),</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">pool_values</span><span class="p">,</span> <span class="n">system_values</span><span class="p">)</span></div>


    <span class="c1">##### plotting methods #####</span>

    
    <span class="c1">## solutions ##</span>


<div class="viewcode-block" id="SmoothModelRun.plot_solutions"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.plot_solutions">[docs]</a>    <span class="k">def</span> <span class="nf">plot_solutions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fig</span><span class="p">,</span> <span class="n">fontsize</span> <span class="o">=</span> <span class="mi">10</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot the solution trajectories.</span>
<span class="sd">    </span>
<span class="sd">        For each trajectory (nr_pools+1) a new subplot is created.</span>
<span class="sd">    </span>
<span class="sd">        Args:</span>
<span class="sd">            fig (Matplotlib figure): The fig to which the subplots are added.</span>
<span class="sd">            fontsize (float, optional): Defaults to 10.</span>
<span class="sd">    </span>
<span class="sd">        Returns:</span>
<span class="sd">            None.</span>
<span class="sd">            Instead ``fig`` is changed in place.</span>
<span class="sd">        &quot;&quot;&quot;</span>
    <span class="c1">#fixme:</span>
    <span class="c1"># since time units and units are related to those</span>
    <span class="c1"># of the other fluxes it would be more consistent</span>
    <span class="c1"># to make them a property of SmoothModelRun and use</span>
    <span class="c1"># them in the other plots as well</span>

        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>
        <span class="n">soln</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>


        <span class="k">def</span> <span class="nf">make_ax_nice</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">title</span><span class="p">):</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="n">fontsize</span> <span class="o">=</span> <span class="n">fontsize</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_add_time_unit</span><span class="p">(</span><span class="n">latex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">time_symbol</span><span class="p">)),</span> 
                            <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_add_content_unit</span><span class="p">(</span><span class="s1">&#39;content&#39;</span><span class="p">),</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mf">0.9</span><span class="p">,</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mf">1.1</span><span class="p">)</span>
        

        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">soln</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">make_ax_nice</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="s1">&#39;System&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">pool</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">+</span><span class="n">pool</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">soln</span><span class="p">[:,</span><span class="n">pool</span><span class="p">])</span>
            <span class="n">make_ax_nice</span><span class="p">(</span>
                <span class="n">ax</span><span class="p">,</span> <span class="s2">&quot;$&quot;</span> <span class="o">+</span> <span class="n">latex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">state_variables</span><span class="p">[</span><span class="n">pool</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot;$&quot;</span><span class="p">)</span>

        <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span></div>
   
 
<div class="viewcode-block" id="SmoothModelRun.plot_phase_plane"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.plot_phase_plane">[docs]</a>    <span class="k">def</span> <span class="nf">plot_phase_plane</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">fontsize</span> <span class="o">=</span> <span class="mi">10</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot one single phase plane.</span>

<span class="sd">        Args:</span>
<span class="sd">            ax (Matplotlib axis): The axis onto which the phase plane is </span>
<span class="sd">                plotted.</span>
<span class="sd">            i, j (int): The numbers of the pools for which the phase plane is </span>
<span class="sd">                plotted.</span>
<span class="sd">            fontsize (float, optional): Defaults to 10.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None.</span>
<span class="sd">            Instead ``ax`` is changed in place.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
        <span class="n">soln</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">soln</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">soln</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])</span>

        <span class="n">x0</span> <span class="o">=</span> <span class="n">soln</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
        <span class="n">y0</span> <span class="o">=</span> <span class="n">soln</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">([</span><span class="n">x0</span><span class="p">],[</span><span class="n">y0</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>

        <span class="n">x1</span> <span class="o">=</span> <span class="n">soln</span><span class="p">[[</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">y1</span> <span class="o">=</span> <span class="n">soln</span><span class="p">[[</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">x2</span> <span class="o">=</span> <span class="n">soln</span><span class="p">[[</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">y2</span> <span class="o">=</span> <span class="n">soln</span><span class="p">[[</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">mpatches</span><span class="o">.</span><span class="n">FancyArrowPatch</span><span class="p">((</span><span class="n">x1</span><span class="p">,</span><span class="n">y1</span><span class="p">),</span> <span class="p">(</span><span class="n">x2</span><span class="p">,</span><span class="n">y2</span><span class="p">),</span> 
                    <span class="n">arrowstyle</span><span class="o">=</span><span class="s1">&#39;simple&#39;</span><span class="p">,</span> <span class="n">mutation_scale</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_add_content_unit</span><span class="p">(</span>
            <span class="s2">&quot;$&quot;</span><span class="o">+</span><span class="n">latex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">state_variables</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">+</span><span class="s2">&quot;$&quot;</span><span class="p">),</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_add_content_unit</span><span class="p">(</span>
            <span class="s2">&quot;$&quot;</span><span class="o">+</span><span class="n">latex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">state_variables</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="o">+</span><span class="s2">&quot;$&quot;</span><span class="p">),</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize</span><span class="p">)</span></div>


<div class="viewcode-block" id="SmoothModelRun.plot_phase_planes"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.plot_phase_planes">[docs]</a>    <span class="k">def</span> <span class="nf">plot_phase_planes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fig</span><span class="p">,</span> <span class="n">fontsize</span> <span class="o">=</span> <span class="mi">10</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot all phase planes.</span>

<span class="sd">        For each (i,j)-phase plane a new subplot is added.</span>

<span class="sd">        Args:</span>
<span class="sd">            fig (Matplotlib figure): The fig to which the subplots are added.</span>
<span class="sd">            fontsize (float, optional): Defaults to 10.</span>
<span class="sd">    </span>
<span class="sd">        Returns:</span>
<span class="sd">            None.</span>
<span class="sd">            Instead ``fig`` is changed in place.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">state_vector</span><span class="p">)</span>
        <span class="n">planes</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span>

        <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">arrange_subplots</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">planes</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">planes</span><span class="p">):</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot_phase_plane</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">fontsize</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">get_xaxis</span><span class="p">()</span><span class="o">.</span><span class="n">set_ticks</span><span class="p">([])</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">get_yaxis</span><span class="p">()</span><span class="o">.</span><span class="n">set_ticks</span><span class="p">([])</span>

        <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span></div>
    

    <span class="c1">## fluxes ##</span>
    

<div class="viewcode-block" id="SmoothModelRun.plot_internal_fluxes"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.plot_internal_fluxes">[docs]</a>    <span class="k">def</span> <span class="nf">plot_internal_fluxes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fig</span><span class="p">,</span> <span class="n">fontsize</span> <span class="o">=</span> <span class="mi">10</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot all internal fluxes.</span>

<span class="sd">        For each internal flux a new subplot is added.</span>

<span class="sd">        Args:</span>
<span class="sd">            fig (Matplotlib figure): The fig to which the subplots are added.</span>
<span class="sd">            fontsize (float, optional): Defaults to 10.</span>
<span class="sd">    </span>
<span class="sd">        Returns:</span>
<span class="sd">            None.</span>
<span class="sd">            Instead ``fig`` is changed in place.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">internal_flux_funcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">internal_flux_funcs</span><span class="p">()</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">internal_flux_funcs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
        <span class="c1">#n=self.nr_pools</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">internal_flux_funcs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="p">[</span><span class="n">internal_flux_funcs</span><span class="p">[</span><span class="n">key</span><span class="p">](</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">times</span><span class="p">])</span>
    
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span>
                <span class="s1">&#39;Flux from $&#39;</span> 
                <span class="o">+</span> <span class="n">latex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">state_variables</span><span class="p">[</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span> 
                <span class="o">+</span> <span class="s1">&#39;$ to $&#39;</span>
                <span class="o">+</span> <span class="n">latex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">state_variables</span><span class="p">[</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span> 
                <span class="o">+</span> <span class="s1">&#39;$&#39;</span><span class="p">,</span>
                <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_add_time_unit</span><span class="p">(</span>
                <span class="s1">&#39;$&#39;</span> <span class="o">+</span> <span class="n">latex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">time_symbol</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;$&#39;</span><span class="p">),</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_add_flux_unit</span><span class="p">(</span><span class="s1">&#39;flux&#39;</span><span class="p">),</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span></div>


<div class="viewcode-block" id="SmoothModelRun.plot_external_output_fluxes"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.plot_external_output_fluxes">[docs]</a>    <span class="k">def</span> <span class="nf">plot_external_output_fluxes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fig</span><span class="p">,</span> <span class="n">fontsize</span> <span class="o">=</span> <span class="mi">10</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot all external output fluxes.</span>

<span class="sd">        For each external output flux a new subplot is added.</span>

<span class="sd">        Args:</span>
<span class="sd">            fig (Matplotlib figure): The fig to which the subplots are added.</span>
<span class="sd">            fontsize (float, optional): Defaults to 10.</span>
<span class="sd">    </span>
<span class="sd">        Returns:</span>
<span class="sd">            None.</span>
<span class="sd">            Instead ``fig`` is changed in place.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
        <span class="n">output_flux_funcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_flux_funcs</span><span class="p">()</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">output_flux_funcs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        
        <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">output_flux_funcs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="p">[</span><span class="n">output_flux_funcs</span><span class="p">[</span><span class="n">key</span><span class="p">](</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">times</span><span class="p">])</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span>
                <span class="s1">&#39;External outflux from $&#39;</span> 
                <span class="o">+</span> <span class="n">latex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">state_variables</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> 
                <span class="o">+</span> <span class="s1">&#39;$&#39;</span><span class="p">,</span> 
                <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_add_time_unit</span><span class="p">(</span><span class="s1">&#39;$&#39;</span> <span class="o">+</span> <span class="n">latex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">time_symbol</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;$&#39;</span><span class="p">),</span> 
                <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_add_flux_unit</span><span class="p">(</span><span class="s1">&#39;flux&#39;</span><span class="p">),</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span></div>
                
    
<div class="viewcode-block" id="SmoothModelRun.plot_external_input_fluxes"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.plot_external_input_fluxes">[docs]</a>    <span class="k">def</span> <span class="nf">plot_external_input_fluxes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fig</span><span class="p">,</span> <span class="n">fontsize</span> <span class="o">=</span> <span class="mi">10</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot all external inpput fluxes.</span>

<span class="sd">        For each external input flux a new subplot is added.</span>

<span class="sd">        Args:</span>
<span class="sd">            fig (Matplotlib figure): The fig to which the subplots are added.</span>
<span class="sd">            fontsize (float, optional): Defaults to 10.</span>
<span class="sd">    </span>
<span class="sd">        Returns:</span>
<span class="sd">            None.</span>
<span class="sd">            Instead ``fig`` is changed in place.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
        <span class="n">input_flux_funcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_input_flux_funcs</span><span class="p">()</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_flux_funcs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">input_flux_funcs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="p">[</span><span class="n">input_flux_funcs</span><span class="p">[</span><span class="n">key</span><span class="p">](</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">times</span><span class="p">])</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span>
                <span class="s1">&#39;External influx to $&#39;</span> 
                <span class="o">+</span> <span class="n">latex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">state_variables</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> 
                <span class="o">+</span> <span class="s1">&#39;$&#39;</span><span class="p">,</span> 
                <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_add_time_unit</span><span class="p">(</span><span class="s1">&#39;$&#39;</span> <span class="o">+</span> <span class="n">latex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">time_symbol</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;$&#39;</span><span class="p">),</span> 
                <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_add_flux_unit</span><span class="p">(</span><span class="s1">&#39;flux&#39;</span><span class="p">),</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span></div>


    <span class="c1"># means # </span>


<div class="viewcode-block" id="SmoothModelRun.plot_mean_ages"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.plot_mean_ages">[docs]</a>    <span class="k">def</span> <span class="nf">plot_mean_ages</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fig</span><span class="p">,</span> <span class="n">start_mean_ages</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot the time evolution of the mean ages for all pools and the </span>
<span class="sd">        system.</span>

<span class="sd">        For each pool and the system a separate subplot is created.</span>

<span class="sd">        Args:</span>
<span class="sd">            fig (Matplotlib figure): The fig to which the subplots are added.</span>
<span class="sd">            start_mean_ages (numpy.array): Contains the start mean ages of the </span>
<span class="sd">                pools at time :math:`t_0`.</span>
<span class="sd">    </span>
<span class="sd">        Returns:</span>
<span class="sd">            None.</span>
<span class="sd">            Instead ``fig`` is changed in place.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>
        <span class="n">start_age_moments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span>
                                <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">start_mean_ages</span><span class="p">))</span>
        <span class="n">time_symbol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">time_symbol</span>
        <span class="n">states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">state_variables</span>

        <span class="n">ma_vector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">age_moment_vector</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">start_age_moments</span><span class="p">)</span>
        <span class="n">sma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">system_age_moment</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">start_age_moments</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">make_ax_nice</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">title</span><span class="p">):</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_add_time_unit</span><span class="p">(</span><span class="s2">&quot;$&quot;</span> <span class="o">+</span> <span class="n">latex</span><span class="p">(</span><span class="n">time_symbol</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;$&quot;</span><span class="p">))</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_add_time_unit</span><span class="p">(</span><span class="s2">&quot;mean age&quot;</span><span class="p">))</span>

            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>

        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">sma</span><span class="p">)</span>
        <span class="n">make_ax_nice</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="s2">&quot;System&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">+</span><span class="n">i</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">ma_vector</span><span class="p">[:,</span><span class="n">i</span><span class="p">])</span>
            <span class="n">make_ax_nice</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="s2">&quot;$&quot;</span> <span class="o">+</span> <span class="n">latex</span><span class="p">(</span><span class="n">states</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot;$&quot;</span><span class="p">)</span>
                
        <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span></div>


<div class="viewcode-block" id="SmoothModelRun.plot_mean_backward_transit_time"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.plot_mean_backward_transit_time">[docs]</a>    <span class="k">def</span> <span class="nf">plot_mean_backward_transit_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">start_mean_ages</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot the time evolution of the mean backward transit time.</span>

<span class="sd">        For each pool and the system a separate subplot is created.</span>

<span class="sd">        Args:</span>
<span class="sd">            ax (Matplotlib axis): The ax onto which the plot is done.</span>
<span class="sd">            start_mean_ages (numpy.array): Contains the start mean ages of the </span>
<span class="sd">                pools at time :math:`t_0`.</span>
<span class="sd">    </span>
<span class="sd">        Returns:</span>
<span class="sd">            None.</span>
<span class="sd">            Instead ``ax`` is changed in place.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>
        <span class="n">start_age_moments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span>
                                <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">start_mean_ages</span><span class="p">))</span>
        <span class="n">time_symbol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">time_symbol</span>
        <span class="n">tr_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">backward_transit_time_moment</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">start_age_moments</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">tr_val</span><span class="p">)</span>
        
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Mean backward transit time&quot;</span><span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_add_time_unit</span><span class="p">(</span><span class="s2">&quot;$&quot;</span> <span class="o">+</span> <span class="n">latex</span><span class="p">(</span><span class="n">time_symbol</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;$&quot;</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_add_time_unit</span><span class="p">(</span><span class="s2">&quot;mean BTT&quot;</span><span class="p">))</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span></div>


    <span class="c1">## densities ##</span>


    <span class="c1"># age #</span>

    
<div class="viewcode-block" id="SmoothModelRun.add_line_to_density_plot_plotly"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.add_line_to_density_plot_plotly">[docs]</a>    <span class="k">def</span> <span class="nf">add_line_to_density_plot_plotly</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fig</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> 
            <span class="n">time_stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">on_surface</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
            <span class="n">legend_on_surface</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">legend_bottom</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a line to an existing Plotly density plot.</span>

<span class="sd">        Args:</span>
<span class="sd">            fig (Plotly figure): Contains already a density plot to which the </span>
<span class="sd">                new line is added.</span>
<span class="sd">            data (numpy.array len(times)): The age data of the new line.</span>
<span class="sd">            color (#RRGGBB): The color of the new line.</span>
<span class="sd">            name (str): The name of the new line for the legend.</span>
<span class="sd">            time_stride (int, optional): Coarsity of the plot in the time </span>
<span class="sd">                direction to save memory. </span>
<span class="sd">                Defaults to 1 meaning that all times are plotted and no memory </span>
<span class="sd">                is saved.</span>
<span class="sd">            width (int, optional): Width of the new line. Defaults to 5.</span>
<span class="sd">            on_surface (bool, optional): If True, a new line with the given age</span>
<span class="sd">                data is plotted on top of the given density.</span>
<span class="sd">                Defaults to True.</span>
<span class="sd">            bottom (bool optional): If True, a new line with the given age data</span>
<span class="sd">                is plotted in the xy-plane. </span>
<span class="sd">                Defaults to True.</span>
<span class="sd">            legend_on_surface (bool, optional): If True, the line on the surface</span>
<span class="sd">                is mentioned in the legend.</span>
<span class="sd">                Has no effect if on_surface is False.</span>
<span class="sd">                Defaults to False.</span>
<span class="sd">            legend_bottom (bool, optional): If True, the line in the xy-plane is</span>
<span class="sd">                mentioned in the legend.</span>
<span class="sd">                Has no effect if bottom is False.</span>
<span class="sd">                Defaults to False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None.</span>
<span class="sd">            Instead ``fig`` is changed in place.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
        <span class="n">strided_data</span> <span class="o">=</span> <span class="n">stride</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">time_stride</span><span class="p">)</span>
        <span class="n">strided_times</span> <span class="o">=</span> <span class="n">stride</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">time_stride</span><span class="p">)</span>
    
        <span class="k">if</span> <span class="n">bottom</span><span class="p">:</span>
            <span class="n">trace_bottom</span> <span class="o">=</span> <span class="n">go</span><span class="o">.</span><span class="n">Scatter3d</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
            <span class="n">x</span><span class="o">=-</span><span class="n">strided_times</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">strided_data</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">0</span><span class="o">*</span><span class="n">strided_times</span><span class="p">,</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;lines&#39;</span><span class="p">,</span>
            <span class="n">line</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
                <span class="n">width</span><span class="o">=</span><span class="n">width</span>
                <span class="p">),</span>
            <span class="n">showlegend</span> <span class="o">=</span> <span class="n">legend_bottom</span>
            <span class="p">)</span>
            <span class="n">fig</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="n">trace_bottom</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">on_surface</span><span class="p">:</span>
            <span class="c1"># compute the density values on the surface</span>
            <span class="c1">#strided_times = -fig[&#39;data&#39;][0][&#39;x&#39;]</span>
            <span class="n">strided_ages</span> <span class="o">=</span> <span class="n">fig</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;y&#39;</span><span class="p">]</span>
            <span class="n">density_data</span> <span class="o">=</span> <span class="n">fig</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;z&#39;</span><span class="p">]</span>

            <span class="n">strided_z</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">ti</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">strided_times</span><span class="p">)):</span>
                <span class="n">time</span> <span class="o">=</span> <span class="n">strided_times</span><span class="p">[</span><span class="n">ti</span><span class="p">]</span>
                <span class="n">age</span> <span class="o">=</span> <span class="n">strided_data</span><span class="p">[</span><span class="n">ti</span><span class="p">]</span>

                <span class="k">if</span> <span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">age</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">age</span> <span class="o">&lt;</span> <span class="n">strided_ages</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">or</span> 
                    <span class="p">(</span><span class="n">age</span> <span class="o">&gt;</span> <span class="n">strided_ages</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])):</span>
                    <span class="n">strided_z</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ti_lower</span> <span class="o">=</span> <span class="n">strided_times</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">time</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
                    <span class="n">ti_upper</span> <span class="o">=</span> <span class="p">(</span><span class="n">ti_lower</span><span class="o">+</span><span class="mi">1</span> <span class="k">if</span> <span class="n">ti_lower</span><span class="o">+</span><span class="mi">1</span><span class="o">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="n">strided_times</span><span class="p">)</span> 
                                            <span class="k">else</span> <span class="n">ti_lower</span><span class="p">)</span>
                    <span class="n">time_lower</span> <span class="o">=</span> <span class="n">strided_times</span><span class="p">[</span><span class="n">ti_lower</span><span class="p">]</span>
                    <span class="n">time_upper</span> <span class="o">=</span> <span class="n">strided_times</span><span class="p">[</span><span class="n">ti_upper</span><span class="p">]</span>
    
                    <span class="n">ai_lower</span> <span class="o">=</span> <span class="n">strided_ages</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">age</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
                    <span class="n">ai_upper</span> <span class="o">=</span> <span class="p">(</span><span class="n">ai_lower</span><span class="o">+</span><span class="mi">1</span> <span class="k">if</span> <span class="n">ai_lower</span><span class="o">+</span><span class="mi">1</span><span class="o">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="n">strided_ages</span><span class="p">)</span> 
                                            <span class="k">else</span> <span class="n">ai_lower</span><span class="p">)</span>
                    <span class="n">age_lower</span> <span class="o">=</span> <span class="n">strided_ages</span><span class="p">[</span><span class="n">ai_lower</span><span class="p">]</span>
                    <span class="n">age_upper</span> <span class="o">=</span> <span class="n">strided_ages</span><span class="p">[</span><span class="n">ai_upper</span><span class="p">]</span>
    
                    <span class="n">bl_density_value</span> <span class="o">=</span> <span class="n">density_data</span><span class="p">[</span><span class="n">ai_lower</span><span class="p">,</span> <span class="n">ti_lower</span><span class="p">]</span>
                    <span class="n">br_density_value</span> <span class="o">=</span> <span class="n">density_data</span><span class="p">[</span><span class="n">ai_lower</span><span class="p">,</span> <span class="n">ti_upper</span><span class="p">]</span>
                    <span class="n">bottom_density_value</span> <span class="o">=</span> <span class="p">(</span><span class="n">bl_density_value</span> <span class="o">+</span> <span class="p">(</span><span class="n">time</span><span class="o">-</span><span class="n">time_lower</span><span class="p">)</span>
                                            <span class="o">/</span><span class="p">(</span><span class="n">time_upper</span><span class="o">-</span><span class="n">time_lower</span><span class="p">)</span><span class="o">*</span>
                                            <span class="p">(</span><span class="n">br_density_value</span><span class="o">-</span><span class="n">bl_density_value</span><span class="p">))</span>
    
                    <span class="n">tl_density_value</span> <span class="o">=</span> <span class="n">density_data</span><span class="p">[</span><span class="n">ai_upper</span><span class="p">,</span> <span class="n">ti_lower</span><span class="p">]</span>
                    <span class="n">tr_density_value</span> <span class="o">=</span> <span class="n">density_data</span><span class="p">[</span><span class="n">ai_upper</span><span class="p">,</span> <span class="n">ti_upper</span><span class="p">]</span>
                    <span class="n">top_density_value</span> <span class="o">=</span> <span class="p">(</span><span class="n">tl_density_value</span> <span class="o">+</span> <span class="p">(</span><span class="n">time</span><span class="o">-</span><span class="n">time_lower</span><span class="p">)</span><span class="o">/</span>
                                            <span class="p">(</span><span class="n">time_upper</span><span class="o">-</span><span class="n">time_lower</span><span class="p">)</span><span class="o">*</span>
                                            <span class="p">(</span><span class="n">tr_density_value</span><span class="o">-</span><span class="n">tl_density_value</span><span class="p">))</span>
    
                    <span class="n">density_value</span> <span class="o">=</span> <span class="p">(</span><span class="n">bottom_density_value</span> <span class="o">+</span> 
                                    <span class="p">(</span><span class="n">age</span><span class="o">-</span><span class="n">age_lower</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">age_upper</span><span class="o">-</span><span class="n">age_lower</span><span class="p">)</span><span class="o">*</span>
                                    <span class="p">(</span><span class="n">top_density_value</span><span class="o">-</span><span class="n">bottom_density_value</span><span class="p">))</span>
                    <span class="n">strided_z</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">density_value</span><span class="p">)</span>

            <span class="n">trace_on_surface</span> <span class="o">=</span> <span class="n">go</span><span class="o">.</span><span class="n">Scatter3d</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
            <span class="n">x</span><span class="o">=-</span><span class="n">strided_times</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">strided_data</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="n">strided_z</span><span class="p">,</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;lines&#39;</span><span class="p">,</span>
            <span class="n">line</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
                <span class="n">width</span><span class="o">=</span><span class="n">width</span>
                <span class="p">),</span>
            <span class="n">showlegend</span> <span class="o">=</span> <span class="n">legend_on_surface</span>
            <span class="p">)</span>
            <span class="n">fig</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="n">trace_on_surface</span><span class="p">]</span></div>

<div class="viewcode-block" id="SmoothModelRun.plot_3d_density_plotly"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.plot_3d_density_plotly">[docs]</a>    <span class="k">def</span> <span class="nf">plot_3d_density_plotly</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">density_data</span><span class="p">,</span> <span class="n">ages</span><span class="p">,</span> 
            <span class="n">age_stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">time_stride</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a 3-dimendional density plot with Plotly.</span>

<span class="sd">        The colors are created such that they are constant along the age-time </span>
<span class="sd">        diagonal.</span>
<span class="sd">        Thus, equal colors mark equal entry time into the system.</span>

<span class="sd">        Args:</span>
<span class="sd">            title (str): The title of the new figure.</span>
<span class="sd">            density_data (numpy.ndarray len(ages) x len(times)): </span>
<span class="sd">                The density data to be plotted.</span>
<span class="sd">            age_stride (int, optional): Coarsity of the plot in the age </span>
<span class="sd">                direction to save memory. </span>
<span class="sd">                Defaults to 1 meaning that all times are plotted and no memory</span>
<span class="sd">                is saved.</span>
<span class="sd">            time_stride (int, optional): Coarsity of the plot in the time </span>
<span class="sd">                direction to save memory. </span>
<span class="sd">                Defaults to 1 meaning that all times are plotted and no memory </span>
<span class="sd">                is saved.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Plotly figure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span><span class="p">,</span> <span class="n">layout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_density_plot_plotly</span><span class="p">(</span>
                                <span class="n">density_data</span><span class="p">,</span> <span class="n">ages</span><span class="p">,</span> <span class="n">age_stride</span><span class="p">,</span> <span class="n">time_stride</span><span class="p">)</span>
        <span class="n">layout</span><span class="p">[</span><span class="s1">&#39;title&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">title</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">go</span><span class="o">.</span><span class="n">Figure</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">layout</span><span class="o">=</span><span class="n">layout</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">fig</span></div>

<div class="viewcode-block" id="SmoothModelRun.add_equilibrium_surface_plotly"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.add_equilibrium_surface_plotly">[docs]</a>    <span class="k">def</span> <span class="nf">add_equilibrium_surface_plotly</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fig</span><span class="p">,</span> <span class="n">opacity</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a grey and transparent equilibrium density surface to an existing</span>
<span class="sd">        Plotly density plot.</span>

<span class="sd">        The &#39;equilibrium&#39; values are taken from the time zero index such that </span>
<span class="sd">        the system is supposed to be in equlibrium at time :math:`t_0`.</span>

<span class="sd">        Args:</span>
<span class="sd">            fig (Plotly figure): The existing density plot to which the </span>
<span class="sd">                equilibrium surface is added.</span>
<span class="sd">            opacity (between 0 and 1, optional): The opacity of the new surface.</span>
<span class="sd">                Defaults to 0.9.</span>
<span class="sd">                Unfortunately, the opacity option does not seem to work </span>
<span class="sd">                properly.</span>
<span class="sd">            index (int, optional): The time index from which the equilibrium </span>
<span class="sd">                data is taken.</span>
<span class="sd">                Defaults to 0 such that the system is supposed to be in </span>
<span class="sd">                equlibrium at time :math:`t_0`.</span>
<span class="sd">    </span>
<span class="sd">        Returns:</span>
<span class="sd">            None.</span>
<span class="sd">            Instead ``fig`` is changed in place.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">fig</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">ti</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">z</span><span class="p">[:,</span><span class="n">ti</span><span class="p">]</span> <span class="o">=</span> <span class="n">z</span><span class="p">[:,</span><span class="n">index</span><span class="p">]</span>
        <span class="n">eq_surface_data</span> <span class="o">=</span> <span class="n">go</span><span class="o">.</span><span class="n">Surface</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> 
                                      <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> 
                                      <span class="n">z</span><span class="o">=</span><span class="n">z</span><span class="p">,</span> 
                                      <span class="n">showscale</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                      <span class="n">opacity</span> <span class="o">=</span> <span class="n">opacity</span><span class="p">,</span>
                                      <span class="n">surfacecolor</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">z</span><span class="p">))</span>
        <span class="n">fig</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eq_surface_data</span><span class="p">)</span></div>


    <span class="c1">##### cumulative distribution methods #####</span>


<div class="viewcode-block" id="SmoothModelRun.cumulative_pool_age_distributions_single_value"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.cumulative_pool_age_distributions_single_value">[docs]</a>    <span class="k">def</span> <span class="nf">cumulative_pool_age_distributions_single_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
            <span class="n">start_age_densities</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">F0</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a function for the cumulative pool age distributions.</span>

<span class="sd">        Args:</span>
<span class="sd">            start_age_densities (Python function, optional): A function of age </span>
<span class="sd">                that returns a numpy.array containing the masses with the given </span>
<span class="sd">                age at time :math:`t_0`. Defaults to None.</span>
<span class="sd">            F0 (Python function): A function of age that returns a numpy.array </span>
<span class="sd">                containing the masses with age less than or equal to the age at </span>
<span class="sd">                time :math:`t_0`. Defaults to None.</span>

<span class="sd">        Raises:</span>
<span class="sd">            Error: If both ``start_age_densities`` and ``F0`` are ``None``. </span>
<span class="sd">                One must be given.</span>
<span class="sd">                It is fastest to provide ``F0``, otherwise ``F0`` will be </span>
<span class="sd">                computed by numerical integration of ``start_age_densities``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Python function ``F_sv``: ``F_sv(a,t)`` is the vector of pool </span>
<span class="sd">            masses (``numpy.array``) with age less than or equal to ``a`` at </span>
<span class="sd">            time ``t``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>
        <span class="n">soln</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">soln</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">start_age_densities</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,))</span>

        <span class="k">if</span> <span class="n">F0</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">start_age_densities</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span><span class="p">(</span><span class="n">Error</span><span class="p">(</span><span class="s1">&#39;Either F0 or start_age_densities must be given.&#39;</span><span class="p">))</span>

        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
        <span class="n">t0</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1">#sol_funcs = self.sol_funcs()</span>
        <span class="c1">#sol_funcs_array = lambda t: np.array([sol_funcs[pool](t) </span>
        <span class="c1">#                                           for pool in range(n)])</span>
        <span class="n">sol_funcs_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve_single_value</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">F0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">p0</span> <span class="o">=</span> <span class="n">start_age_densities</span>
            <span class="n">F0</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">p0</span><span class="p">(</span><span class="n">s</span><span class="p">)[</span><span class="n">pool</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">a</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> 
                                        <span class="k">for</span> <span class="n">pool</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)])</span>

        <span class="n">Phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state_transition_operator</span>

        <span class="k">def</span> <span class="nf">G_sv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">t</span><span class="o">-</span><span class="n">t0</span><span class="p">:</span> <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,))</span>
            <span class="c1">#print(t, t0, a-(t-t0))</span>
            <span class="k">return</span> <span class="n">Phi</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">F0</span><span class="p">(</span><span class="n">a</span><span class="o">-</span><span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="n">t0</span><span class="p">)))</span>


        <span class="k">def</span> <span class="nf">H_sv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
            <span class="c1"># count everything from beginning?</span>
            <span class="k">if</span> <span class="n">a</span> <span class="o">&gt;=</span> <span class="n">t</span><span class="o">-</span><span class="n">t0</span><span class="p">:</span> <span class="n">a</span> <span class="o">=</span> <span class="n">t</span><span class="o">-</span><span class="n">t0</span>

            <span class="c1"># mass at time t</span>
            <span class="c1">#x_t_old = np.array([sol_funcs[pool](t) for pool in range(n)])</span>
            <span class="n">x_t</span> <span class="o">=</span> <span class="n">sol_funcs_array</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="c1"># mass at time t-a</span>
            <span class="c1">#x_tma_old = [np.float(sol_funcs[pool](t-a)) for pool in range(n)]</span>
            <span class="n">x_tma</span> <span class="o">=</span> <span class="n">sol_funcs_array</span><span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="n">a</span><span class="p">)</span>
            <span class="c1"># what remains from x_tma at time t</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">Phi</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="o">-</span><span class="n">a</span><span class="p">,</span> <span class="n">x_tma</span><span class="p">)</span>
            <span class="c1"># difference is not older than t-a</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">x_t</span><span class="o">-</span><span class="n">m</span>
            <span class="c1"># cut off accidental negative values</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

        <span class="k">return</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">G_sv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">H_sv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">t</span><span class="p">)</span></div>

<div class="viewcode-block" id="SmoothModelRun.cumulative_system_age_distribution_single_value"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.cumulative_system_age_distribution_single_value">[docs]</a>    <span class="k">def</span> <span class="nf">cumulative_system_age_distribution_single_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
            <span class="n">start_age_densities</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">F0</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a function for the cumulative system age distribution.</span>

<span class="sd">        Args:</span>
<span class="sd">            start_age_densities (Python function, optional): A function of age </span>
<span class="sd">                that returns a numpy.array containing the masses with the given </span>
<span class="sd">                age at time :math:`t_0`. Defaults to None.</span>
<span class="sd">            F0 (Python function): A function of age that returns a numpy.array </span>
<span class="sd">                containing the masses with age less than or equal to the age at </span>
<span class="sd">                time :math:`t_0`. Defaults to None.</span>

<span class="sd">        Raises:</span>
<span class="sd">            Error: If both ``start_age_densities`` and ``F0`` are None. </span>
<span class="sd">                One must be given.</span>
<span class="sd">                It is fastest to provide ``F0``, otherwise ``F0`` will be </span>
<span class="sd">                computed by numerical integration of ``start_age_densities``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Python function ``F_sv``: ``F_sv(a, t)`` is the mass in the system </span>
<span class="sd">            with age less than or equal to ``a`` at time ``t``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>
        <span class="n">soln</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">soln</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">start_age_densities</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,))</span>
        
        <span class="k">if</span> <span class="n">F0</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">start_age_densities</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span><span class="p">(</span><span class="n">Error</span><span class="p">(</span><span class="s1">&#39;Either F0 or start_age_densities must be given.&#39;</span><span class="p">))</span>

        <span class="n">F_sv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cumulative_pool_age_distributions_single_value</span><span class="p">(</span>
                <span class="n">start_age_densities</span><span class="o">=</span><span class="n">start_age_densities</span><span class="p">,</span> <span class="n">F0</span><span class="o">=</span><span class="n">F0</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">F_sv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span></div>

    <span class="c1">#fixme: test</span>
<div class="viewcode-block" id="SmoothModelRun.cumulative_backward_transit_time_distribution_single_value"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.cumulative_backward_transit_time_distribution_single_value">[docs]</a>    <span class="k">def</span> <span class="nf">cumulative_backward_transit_time_distribution_single_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">start_age_densities</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">F0</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a function for the cumulative backward transit time </span>
<span class="sd">        distribution.</span>

<span class="sd">        Args:</span>
<span class="sd">            start_age_densities (Python function, optional): A function of age</span>
<span class="sd">                that returns a numpy.array containing the masses with the given</span>
<span class="sd">                age at time :math:`t_0`. Defaults to None.</span>
<span class="sd">            F0 (Python function): A function of age that returns a numpy.array</span>
<span class="sd">                containing the masses with age less than or equal to the age at</span>
<span class="sd">                time :math:`t_0`. Defaults to None.</span>

<span class="sd">        Raises:</span>
<span class="sd">            Error: If both ``start_age_densities`` and ``F0`` are ``None``. </span>
<span class="sd">                One must be given.</span>
<span class="sd">                It is fastest to provide ``F0``, otherwise ``F0`` will be </span>
<span class="sd">                computed by numerical integration of ``start_age_densities``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Python function ``F_sv``: ``F_sv(a, t)`` is the mass leaving the </span>
<span class="sd">            system at time ``t`` with age less than or equal to ``a``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">F0</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">start_age_densities</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span><span class="p">(</span><span class="n">Error</span><span class="p">(</span><span class="s1">&#39;Either F0 or start_age_densities must be given.&#39;</span><span class="p">))</span>

        <span class="n">F_sv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cumulative_pool_age_distributions_single_value</span><span class="p">(</span>
                <span class="n">start_age_densities</span><span class="o">=</span><span class="n">start_age_densities</span><span class="p">,</span> <span class="n">F0</span><span class="o">=</span><span class="n">F0</span><span class="p">)</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_rate_vector_at_t</span>

        <span class="k">def</span> <span class="nf">F_btt_sv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
            <span class="n">res</span> <span class="o">=</span> <span class="p">(</span><span class="n">rho</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">F_sv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="c1">#print(a, t, res)</span>
            <span class="k">return</span> <span class="n">res</span>

        <span class="k">return</span> <span class="n">F_btt_sv</span></div>

    <span class="c1">#fixme: test</span>
<div class="viewcode-block" id="SmoothModelRun.cumulative_forward_transit_time_distribution_single_value"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.cumulative_forward_transit_time_distribution_single_value">[docs]</a>    <span class="k">def</span> <span class="nf">cumulative_forward_transit_time_distribution_single_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
            <span class="n">cut_off</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a function for the cumulative forward transit time </span>
<span class="sd">        distribution.</span>

<span class="sd">        Args:</span>
<span class="sd">            cut_off (bool, optional): If ``True``, no density values are going </span>
<span class="sd">                to be computed after the end of the time grid, instead </span>
<span class="sd">                ``numpy.nan`` will be returned. </span>
<span class="sd">                Defaults to ``True``.</span>
<span class="sd">                ``False`` might lead to unexpected behavior.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Python function ``F_sv``: ``F_sv(a, t)`` is the mass leaving the </span>
<span class="sd">            system at time ``t+a`` with age less than or equal to ``a``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
        <span class="n">t_max</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">Phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state_transition_operator</span>
        <span class="n">u_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_input_vector_func</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">F_ftt_sv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
            <span class="c1">#print(a, t, a+t&gt;t_max)</span>
            <span class="k">if</span> <span class="n">cut_off</span> <span class="ow">and</span> <span class="n">a</span><span class="o">+</span><span class="n">t</span><span class="o">&gt;</span><span class="n">t_max</span><span class="p">:</span> <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">u_func</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">-</span> <span class="n">Phi</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="c1">#print(a, t, u, res)</span>
            <span class="k">return</span> <span class="n">res</span>

        <span class="k">return</span> <span class="n">F_ftt_sv</span></div>


    <span class="c1">##### quantiles #####</span>


<div class="viewcode-block" id="SmoothModelRun.pool_age_distributions_quantiles"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.pool_age_distributions_quantiles">[docs]</a>    <span class="k">def</span> <span class="nf">pool_age_distributions_quantiles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">quantile</span><span class="p">,</span>  <span class="n">start_values</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
            <span class="n">start_age_densities</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">F0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;brentq&#39;</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return pool age distribution quantiles over the time grid.</span>

<span class="sd">        The compuation is done by computing the generalized inverse of the </span>
<span class="sd">        respective cumulative distribution using a nonlinear root search </span>
<span class="sd">        algorithm. Depending on how slowly the cumulative distribution can be </span>
<span class="sd">        computed, this can take quite some time.</span>

<span class="sd">        Args:</span>
<span class="sd">            quantile (between 0 and 1): The relative share of mass that is </span>
<span class="sd">                considered to be left of the computed value. A value of ``0.5`` </span>
<span class="sd">                leads to the computation of the median of the distribution.</span>
<span class="sd">            start_age_densities (Python function, optional): A function of age </span>
<span class="sd">                that returns a ``numpy.array`` containing the masses with the </span>
<span class="sd">                given age at time :math:`t_0`. </span>
<span class="sd">                Defaults to ``None``.</span>
<span class="sd">            F0 (Python function): A function of age that returns a </span>
<span class="sd">                ``numpy.array`` containing the masses with age less than or</span>
<span class="sd">                equal to the age at time :math:`t_0`. </span>
<span class="sd">                Defaults to ``None``.</span>
<span class="sd">            method (str): The method that is used for finding the roots of a </span>
<span class="sd">                nonlinear function. Either &#39;brentq&#39; or &#39;newton&#39;. </span>
<span class="sd">                Defaults to &#39;brentq&#39;.</span>
<span class="sd">            tol (float): The tolerance used in the numerical root search </span>
<span class="sd">                algorithm. A low tolerance decreases the computation speed </span>
<span class="sd">                tremendously, so a value of ``1e-01`` might already be fine. </span>
<span class="sd">                Defaults to ``1e-08``.</span>

<span class="sd">        Raises:</span>
<span class="sd">            Error: If both ``start_age_densities`` and ``F0`` are ``None``. </span>
<span class="sd">                One must be given.</span>
<span class="sd">                It is fastest to provide ``F0``, otherwise ``F0`` will be </span>
<span class="sd">                computed by numerical integration of ``start_age_densities``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: (len(times) x nr_pools)</span>
<span class="sd">            The computed quantile values over the time-pool grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>
        <span class="n">soln</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">soln</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">start_age_densities</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,))</span>

        <span class="k">if</span> <span class="n">F0</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">start_age_densities</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span><span class="p">(</span><span class="n">Error</span><span class="p">(</span><span class="s1">&#39;Either F0 or start_age_densities must be given.&#39;</span><span class="p">))</span>

        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>

        <span class="k">if</span> <span class="n">start_values</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">),</span> <span class="n">n</span><span class="p">))</span>

        <span class="n">F_sv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cumulative_pool_age_distributions_single_value</span><span class="p">(</span>
                    <span class="n">start_age_densities</span><span class="o">=</span><span class="n">start_age_densities</span><span class="p">,</span> <span class="n">F0</span><span class="o">=</span><span class="n">F0</span><span class="p">)</span>
        <span class="n">soln</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>

        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">pool</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Pool:&#39;</span><span class="p">,</span> <span class="n">pool</span><span class="p">)</span>
            <span class="n">F_sv_pool</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">F_sv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">t</span><span class="p">)[</span><span class="n">pool</span><span class="p">]</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distribution_quantiles</span><span class="p">(</span><span class="n">quantile</span><span class="p">,</span>
                                           <span class="n">F_sv_pool</span><span class="p">,</span>
                                           <span class="n">norm_consts</span> <span class="o">=</span> <span class="n">soln</span><span class="p">[:,</span><span class="n">pool</span><span class="p">],</span>
                                           <span class="n">start_values</span> <span class="o">=</span> <span class="n">start_values</span><span class="p">[:,</span><span class="n">pool</span><span class="p">],</span>
                                           <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="p">,</span>
                                           <span class="n">tol</span> <span class="o">=</span> <span class="n">tol</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">res</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span></div>
    
<div class="viewcode-block" id="SmoothModelRun.system_age_distribution_quantiles"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.system_age_distribution_quantiles">[docs]</a>    <span class="k">def</span> <span class="nf">system_age_distribution_quantiles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">quantile</span><span class="p">,</span> <span class="n">start_values</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
            <span class="n">start_age_densities</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">F0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;brentq&#39;</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return system age distribution quantiles over the time grid.</span>

<span class="sd">        The compuation is done by computing the generalized inverse of the </span>
<span class="sd">        respective cumulative distribution using a nonlinear root search </span>
<span class="sd">        algorithm. Depending on how slowly the cumulative distribution can be </span>
<span class="sd">        computed, this can take quite some time.</span>

<span class="sd">        Args:</span>
<span class="sd">            quantile (between 0 and 1): The relative share of mass that is </span>
<span class="sd">                considered to be left of the computed value. A value of ``0.5`` </span>
<span class="sd">                leads to the computation of the median of the distribution.</span>
<span class="sd">            start_age_densities (Python function, optional): A function of age </span>
<span class="sd">                that returns a ``numpy.array`` containing the masses with the </span>
<span class="sd">                given age at time :math:`t_0`. </span>
<span class="sd">                Defaults to ``None``.</span>
<span class="sd">            F0 (Python function): A function of age that returns a </span>
<span class="sd">                ``numpy.array`` containing the masses with age less than or </span>
<span class="sd">                equal to the age at time :math:`t_0`. </span>
<span class="sd">                Defaults to ``None``.</span>
<span class="sd">            method (str): The method that is used for finding the roots of a </span>
<span class="sd">                nonlinear function. Either &#39;brentq&#39; or &#39;newton&#39;. </span>
<span class="sd">                Defaults to &#39;brentq&#39;.</span>
<span class="sd">            tol (float): The tolerance used in the numerical root search </span>
<span class="sd">                algorithm. A low tolerance decreases the computation speed </span>
<span class="sd">                tremendously, so a value of ``1e-01`` might already be fide. </span>
<span class="sd">                Defaults to ``1e-08``.</span>

<span class="sd">        Raises:</span>
<span class="sd">            Error: If both ``start_age_densities`` and ``F0`` are ``None``. </span>
<span class="sd">                One must be given.</span>
<span class="sd">                It is fastest to provide ``F0``, otherwise ``F0`` will be </span>
<span class="sd">                computed by numerical integration of ``start_age_densities``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.array: The computed quantile values over the time grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>
        <span class="n">soln</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">soln</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">start_age_densities</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,))</span>

        <span class="k">if</span> <span class="n">F0</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">start_age_densities</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span><span class="p">(</span><span class="n">Error</span><span class="p">(</span><span class="s1">&#39;Either F0 or start_age_densities must be given.&#39;</span><span class="p">))</span>
        
        <span class="n">F_sv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cumulative_system_age_distribution_single_value</span><span class="p">(</span>
                    <span class="n">start_age_densities</span><span class="o">=</span><span class="n">start_age_densities</span><span class="p">,</span> <span class="n">F0</span><span class="o">=</span><span class="n">F0</span><span class="p">)</span>
        <span class="n">soln</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
        <span class="n">start_age_moments</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">moments_from_densities</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">start_age_densities</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">start_values</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> 
            <span class="n">start_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">system_age_moment</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">start_age_moments</span><span class="p">)</span>
        <span class="n">a_star</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distribution_quantiles</span><span class="p">(</span><span class="n">quantile</span><span class="p">,</span> 
                                             <span class="n">F_sv</span><span class="p">,</span> 
                                             <span class="n">norm_consts</span> <span class="o">=</span> <span class="n">soln</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> 
                                             <span class="n">start_values</span><span class="o">=</span><span class="n">start_values</span><span class="p">,</span> 
                                             <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                                             <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">a_star</span></div>


<div class="viewcode-block" id="SmoothModelRun.distribution_quantiles"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.distribution_quantiles">[docs]</a>    <span class="k">def</span> <span class="nf">distribution_quantiles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">quantile</span><span class="p">,</span> <span class="n">F_sv</span><span class="p">,</span> 
            <span class="n">norm_consts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">start_values</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;brentq&#39;</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return distribution quantiles over the time grid of a given </span>
<span class="sd">        distribution.</span>

<span class="sd">        The compuation is done by computing the generalized inverse of the </span>
<span class="sd">        respective cumulative distribution using a nonlinear root search </span>
<span class="sd">        algorithm. Depending on how slowly the cumulative distribution can be </span>
<span class="sd">        computed, this can take quite some time.</span>

<span class="sd">        Args:</span>
<span class="sd">            quantile (between 0 and 1): The relative share of mass that is </span>
<span class="sd">                considered to be left of the computed value. A value of ``0.5`` </span>
<span class="sd">                leads to the computation of the median of the distribution.</span>
<span class="sd">            F_sv (Python function): A function of age ``a`` and time ``t`` that </span>
<span class="sd">                returns the mass that is of age less than or equal to ``a`` at </span>
<span class="sd">                time ``t``.</span>
<span class="sd">            norm_consts (numpy.array, optional): An array over the time grid of</span>
<span class="sd">                total masses over all ages. </span>
<span class="sd">                Defaults to an array of ones assuming given probability </span>
<span class="sd">                distributions.</span>
<span class="sd">            start_values (numpy.array, optional): An array over the time grid of</span>
<span class="sd">                start values for the nonlinear search.</span>
<span class="sd">                Good values are slighty greater than the solution values.</span>
<span class="sd">                Defaults to an array of zeros.</span>
<span class="sd">            method (str): The method that is used for finding the roots of a </span>
<span class="sd">                nonlinear function. Either &#39;brentq&#39; or &#39;newton&#39;. </span>
<span class="sd">                Defaults to &#39;brentq&#39;.</span>
<span class="sd">            tol (float): The tolerance used in the numerical root search </span>
<span class="sd">                algorithm. A low tolerance decreases the computation speed </span>
<span class="sd">                tremendously, so a value of ``1e-01`` might already be fine. </span>
<span class="sd">                Defaults to ``1e-08``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.array: The computed quantile values over the time grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
        
        <span class="k">if</span> <span class="n">start_values</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">times</span><span class="p">,))</span>

        <span class="k">if</span> <span class="n">norm_consts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">norm_consts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">times</span><span class="p">,))</span>

        <span class="k">def</span> <span class="nf">quantile_at_ti</span><span class="p">(</span><span class="n">ti</span><span class="p">):</span>
            <span class="c1">#print(&#39;ti&#39;, ti)</span>
            <span class="k">if</span> <span class="n">norm_consts</span><span class="p">[</span><span class="n">ti</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

            <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">a</span><span class="p">):</span> <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">res</span> <span class="o">=</span>  <span class="n">quantile</span><span class="o">*</span><span class="n">norm_consts</span><span class="p">[</span><span class="n">ti</span><span class="p">]</span> <span class="o">-</span> <span class="n">F_sv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">times</span><span class="p">[</span><span class="n">ti</span><span class="p">])</span>
                <span class="c1">#print(&#39;a:&#39;, a,&#39;t&#39;, times[ti], &#39;g(a):&#39;, res, &#39;nc&#39;, </span>
                <span class="c1">#           norm_consts[ti], &#39;F_sv&#39;, F_sv(a, times[ti]))</span>
                <span class="k">return</span> <span class="n">res</span>

            <span class="n">start_age</span> <span class="o">=</span> <span class="n">start_values</span><span class="p">[</span><span class="n">ti</span><span class="p">]</span>
            
            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;newton&#39;</span><span class="p">:</span> 
                <span class="n">a_star</span> <span class="o">=</span> <span class="n">newton</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">start_age</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;brentq&#39;</span><span class="p">:</span> 
                <span class="n">a_star</span> <span class="o">=</span> <span class="n">generalized_inverse_CDF</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">F_sv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">times</span><span class="p">[</span><span class="n">ti</span><span class="p">]),</span> 
                                                 <span class="n">quantile</span><span class="o">*</span><span class="n">norm_consts</span><span class="p">[</span><span class="n">ti</span><span class="p">],</span> 
                                                 <span class="n">start_dist</span><span class="o">=</span><span class="n">start_age</span><span class="p">,</span> 
                                                 <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">a_star</span>

        <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>
        <span class="c1">#q_lst = [quantile_at_ti(ti) for ti in range(len(times))]</span>

        <span class="n">q_lst</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ti</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">))):</span>
            <span class="n">q_lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">quantile_at_ti</span><span class="p">(</span><span class="n">ti</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">q_lst</span><span class="p">)</span></div>


    <span class="c1">## by ode ##</span>


<div class="viewcode-block" id="SmoothModelRun.pool_age_distributions_quantiles_by_ode"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.pool_age_distributions_quantiles_by_ode">[docs]</a>    <span class="k">def</span> <span class="nf">pool_age_distributions_quantiles_by_ode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">quantile</span><span class="p">,</span> 
            <span class="n">start_age_densities</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">F0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return pool age distribution quantiles over the time grid.</span>

<span class="sd">        The compuation is done by solving an ODE for each pool as soon as the </span>
<span class="sd">        pool is nonempty.</span>
<span class="sd">        The initial value is obtained by computing the generalized inverse of </span>
<span class="sd">        the pool age distribution by a numerical root search algorithm.</span>

<span class="sd">        Args:</span>
<span class="sd">            quantile (between 0 and 1): The relative share of mass that is </span>
<span class="sd">                considered to be left of the computed value. A value of ``0.5`` </span>
<span class="sd">                leads to the computation of the median of the distribution.</span>
<span class="sd">            start_age_densities (Python function, optional): A function of age </span>
<span class="sd">                that returns a ``numpy.array`` containing the masses with the </span>
<span class="sd">                given age at time :math:`t_0`. </span>
<span class="sd">                Defaults to ``None``.</span>
<span class="sd">            F0 (Python function): A function of age that returns a </span>
<span class="sd">                ``numpy.array`` containing the masses with age less than or </span>
<span class="sd">                equal to the age at time :math:`t_0`. </span>
<span class="sd">                Defaults to ``None``.</span>
<span class="sd">            tol (float): The tolerance used in the numerical root search </span>
<span class="sd">                algorithm. A low tolerance decreases the computation speed </span>
<span class="sd">                tremendously, so a value of ``1e-01`` might already be fine. </span>
<span class="sd">                Defaults to ``1e-08``.</span>

<span class="sd">        Raises:</span>
<span class="sd">            Error: If both ``start_age_densities`` and ``F0`` are ``None``. </span>
<span class="sd">                One must be given.</span>
<span class="sd">                It is fastest to provide ``F0``, otherwise ``F0`` will be </span>
<span class="sd">                computed by numerical integration of ``start_age_densities``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: (len(times) x nr_pools) The computed quantile values </span>
<span class="sd">            over the time-pool grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">pool</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Pool:&#39;</span><span class="p">,</span> <span class="n">pool</span><span class="p">)</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pool_age_distribution_quantiles_pool_by_ode</span><span class="p">(</span>
                            <span class="n">quantile</span><span class="p">,</span> 
                            <span class="n">pool</span><span class="p">,</span>
                            <span class="n">start_age_densities</span><span class="o">=</span><span class="n">start_age_densities</span><span class="p">,</span>
                            <span class="n">F0</span><span class="o">=</span><span class="n">F0</span><span class="p">,</span>
                            <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">res</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span></div>

<div class="viewcode-block" id="SmoothModelRun.pool_age_distribution_quantiles_pool_by_ode"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.pool_age_distribution_quantiles_pool_by_ode">[docs]</a>    <span class="k">def</span> <span class="nf">pool_age_distribution_quantiles_pool_by_ode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">quantile</span><span class="p">,</span> <span class="n">pool</span><span class="p">,</span> 
            <span class="n">start_age_densities</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">F0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return pool age distribution quantile over the time grid for one </span>
<span class="sd">        single pool.</span>

<span class="sd">        The compuation is done by solving an ODE as soon as the pool is </span>
<span class="sd">        nonempty.</span>
<span class="sd">        The initial value is obtained by computing the generalized inverse of </span>
<span class="sd">        the pool age distribution by a numerical root search algorithm.</span>

<span class="sd">        Args:</span>
<span class="sd">            quantile (between 0 and 1): The relative share of mass that is </span>
<span class="sd">                considered to be left of the computed value. A value of ``0.5`` </span>
<span class="sd">                leads to the computation of the median of the distribution.</span>
<span class="sd">            pool (int): The number of the pool for which the age quantile is to </span>
<span class="sd">                be computed.</span>
<span class="sd">            start_age_densities (Python function, optional): A function of age </span>
<span class="sd">                that returns a ``numpy.array`` containing the masses with the </span>
<span class="sd">                given age at time :math:`t_0`. </span>
<span class="sd">                Defaults to ``None``.</span>
<span class="sd">            F0 (Python function): A function of age that returns a </span>
<span class="sd">                ``numpy.array`` containing the masses with age less than or </span>
<span class="sd">                equal to the age at time :math:`t_0`. </span>
<span class="sd">                Defaults to ``None``.</span>
<span class="sd">            tol (float): The tolerance used in the numerical root search </span>
<span class="sd">                algorithm. A low tolerance decreases the computation speed </span>
<span class="sd">                tremendously, so a value of ``1e-01`` might already be fine. </span>
<span class="sd">                Defaults to ``1e-08``.</span>

<span class="sd">        Raises:</span>
<span class="sd">            Error: If both ``start_age_densities`` and ``F0`` are ``None``. </span>
<span class="sd">                One must be given.</span>
<span class="sd">                It is fastest to provide ``F0``, otherwise ``F0`` will be </span>
<span class="sd">                computed by numerical integration of ``start_age_densities``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: (len(times)) The computed quantile values over the </span>
<span class="sd">            time grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">soln</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
        <span class="n">empty</span> <span class="o">=</span> <span class="n">soln</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">pool</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">empty</span> <span class="ow">and</span> <span class="n">F0</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">start_age_densities</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span><span class="p">(</span><span class="n">Error</span><span class="p">(</span><span class="s1">&#39;Either F0 or start_age_densities must be given.&#39;</span><span class="p">))</span>
        
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">empty</span> <span class="ow">and</span> <span class="n">F0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">p0</span> <span class="o">=</span> <span class="n">start_age_densities</span>
            <span class="n">F0</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">p0</span><span class="p">(</span><span class="n">s</span><span class="p">)[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">a</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> 
                                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)])</span>
        
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pool_age_densities_single_value</span><span class="p">(</span><span class="n">start_age_densities</span><span class="p">)</span>
        <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_input_vector_func</span><span class="p">()</span>
        <span class="n">F</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cumulative_pool_age_distributions_single_value</span><span class="p">(</span>
                <span class="n">start_age_densities</span><span class="o">=</span><span class="n">start_age_densities</span><span class="p">,</span> <span class="n">F0</span><span class="o">=</span><span class="n">F0</span><span class="p">)</span>
        <span class="n">sol_funcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve_single_value</span><span class="p">()</span>

        <span class="c1"># find last time index such that the pool is empty --&gt; ti</span>
        <span class="n">ti</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">content</span> <span class="o">=</span> <span class="n">soln</span><span class="p">[</span><span class="n">ti</span><span class="p">,</span> <span class="n">pool</span><span class="p">]</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">content</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">ti</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span> 
            <span class="n">ti</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-</span><span class="mi">1</span>
            <span class="n">content</span> <span class="o">=</span> <span class="n">soln</span><span class="p">[</span><span class="n">ti</span><span class="p">,</span> <span class="n">pool</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">content</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">ti</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ti</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)):</span> <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">),))</span>
  
        <span class="k">if</span> <span class="n">ti</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">sv</span> <span class="o">=</span> <span class="n">generalized_inverse_CDF</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">F0</span><span class="p">(</span><span class="n">a</span><span class="p">)[</span><span class="n">pool</span><span class="p">],</span> 
                                         <span class="n">quantile</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">start_values</span><span class="p">[</span><span class="n">pool</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#if start_age_densities is None:</span>
            <span class="c1">#    raise(Error(&#39;Cannot start delayed quantile computation,&#39;</span>
            <span class="c1">#                    &#39;since start_age_densities are missing.&#39;))</span>
            <span class="n">CDFs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cumulative_pool_age_distributions_single_value</span><span class="p">(</span>
                        <span class="n">start_age_densities</span><span class="p">)</span>
            <span class="n">CDF</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">CDFs</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">times</span><span class="p">[</span><span class="n">ti</span><span class="p">])</span>
            <span class="n">sv</span> <span class="o">=</span> <span class="n">generalized_inverse_CDF</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">CDF</span><span class="p">(</span><span class="n">a</span><span class="p">)[</span><span class="n">pool</span><span class="p">],</span> 
                                         <span class="n">quantile</span><span class="o">*</span><span class="n">soln</span><span class="p">[</span><span class="n">ti</span><span class="p">,</span> <span class="n">pool</span><span class="p">])</span>

        <span class="n">times</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="n">ti</span><span class="p">:]</span>

        <span class="n">t_max</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">t_min</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">pb</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">total</span> <span class="o">=</span> <span class="n">t_max</span><span class="o">-</span><span class="n">t_min</span><span class="p">)</span>

        <span class="k">global</span> <span class="n">last_t</span><span class="p">,</span> <span class="n">last_res</span>
        <span class="n">last_t</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">last_res</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>

        <span class="k">def</span> <span class="nf">rhs</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">t_val</span><span class="p">):</span>
            <span class="c1">#print(&#39;y&#39;, y, &#39;t&#39;, t_val)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
            <span class="k">global</span> <span class="n">last_t</span><span class="p">,</span> <span class="n">last_res</span>
            
            <span class="n">t_val</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">t_val</span><span class="p">,</span> <span class="n">t_max</span><span class="p">)</span>
            
            <span class="c1"># rhs will be called twice with the same value apparently,  </span>
            <span class="c1"># we can use this to speed it up</span>
            <span class="k">if</span> <span class="n">t_val</span> <span class="o">==</span> <span class="n">last_t</span><span class="p">:</span> <span class="k">return</span> <span class="n">last_res</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">t_val</span> <span class="o">&lt;=</span> <span class="n">t_max</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">t_val</span><span class="o">-</span><span class="n">t_min</span><span class="o">-</span><span class="n">pb</span><span class="o">.</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                <span class="c1">#pb.n = t_val-t_min</span>
                <span class="c1">#pb.update(0)</span>
                <span class="n">pb</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">t_val</span><span class="o">-</span><span class="n">t_min</span><span class="o">-</span><span class="n">pb</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>

            <span class="c1">#print(&#39;y&#39;, y, &#39;t&#39;, t_val)</span>
        
            <span class="n">p_val</span> <span class="o">=</span> <span class="n">p</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">t_val</span><span class="p">)[</span><span class="n">pool</span><span class="p">]</span>
            <span class="n">u_val</span> <span class="o">=</span> <span class="n">u</span><span class="p">(</span><span class="n">t_val</span><span class="p">)[</span><span class="n">pool</span><span class="p">]</span>
            <span class="n">F_vec</span> <span class="o">=</span> <span class="n">F</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">t_val</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">x_vec</span> <span class="o">=</span> <span class="n">sol_funcs</span><span class="p">(</span><span class="n">t_val</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">(</span><span class="n">t_val</span><span class="p">)</span>

            <span class="c1">#print(&#39;A&#39;, A)</span>
            <span class="c1">#print(&#39;x&#39;, x_vec)</span>
            <span class="c1">#print(&#39;A*x&#39;, A.dot(x_vec))</span>
            <span class="c1">#print(&#39;p&#39;, p_val)</span>
            <span class="c1">#print(&#39;u&#39;, u_val)</span>
            <span class="c1">#print(&#39;F&#39;, F_vec)</span>
            <span class="c1">#print(&#39;A*F&#39;, A.dot(F_vec))</span>
            <span class="c1">#print(A.dot(F_vec)[pool])</span>
            <span class="c1">#print(A.dot(F_vec)[1])</span>

            <span class="k">if</span> <span class="n">p_val</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span><span class="p">(</span><span class="n">Error</span><span class="p">(</span><span class="s1">&#39;Division by zero during quantile computation.&#39;</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">p_val</span><span class="o">*</span><span class="p">(</span><span class="n">u_val</span><span class="o">*</span><span class="p">(</span><span class="n">quantile</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>
                        <span class="o">+</span><span class="n">quantile</span><span class="o">*</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x_vec</span><span class="p">))[</span><span class="n">pool</span><span class="p">]</span><span class="o">-</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">F_vec</span><span class="p">))[</span><span class="n">pool</span><span class="p">]))</span>
            <span class="c1">#print(&#39;res&#39;, res)</span>
            <span class="c1">#print(&#39;---&#39;)</span>

            <span class="n">last_t</span> <span class="o">=</span> <span class="n">t_val</span>
            <span class="n">last_res</span> <span class="o">=</span> <span class="n">res</span>
            <span class="k">return</span> <span class="n">res</span>

        <span class="n">short_res</span> <span class="o">=</span> <span class="n">odeint</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">sv</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span> <span class="n">mxstep</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
        <span class="n">pb</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">),))</span>
        <span class="n">res</span><span class="p">[:</span><span class="n">ti</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">res</span><span class="p">[</span><span class="n">ti</span><span class="p">:]</span> <span class="o">=</span> <span class="n">short_res</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">),))</span>

        <span class="c1">#print(res)</span>
        <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="SmoothModelRun.system_age_distribution_quantiles_by_ode"><a class="viewcode-back" href="../../_autosummary/CompartmentalSystems.smooth_model_run.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.system_age_distribution_quantiles_by_ode">[docs]</a>    <span class="k">def</span> <span class="nf">system_age_distribution_quantiles_by_ode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">quantile</span><span class="p">,</span> 
            <span class="n">start_age_densities</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">F0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return system age distribution quantile over the time grid.</span>

<span class="sd">        The compuation is done by solving an ODE as soon as the system is </span>
<span class="sd">        nonempty.</span>
<span class="sd">        The initial value is obtained by computing the generalized inverse of </span>
<span class="sd">        the system age distribution by a numerical root search algorithm.</span>

<span class="sd">        Args:</span>
<span class="sd">            quantile (between 0 and 1): The relative share of mass that is </span>
<span class="sd">                considered to be left of the computed value. A value of ``0.5`` </span>
<span class="sd">                leads to the computation of the median of the distribution.</span>
<span class="sd">            pool (int): The number of the pool for which the age quantile is to </span>
<span class="sd">                be computed.</span>
<span class="sd">            start_age_densities (Python function, optional): A function of age </span>
<span class="sd">                that returns a ``numpy.array`` containing the masses with the </span>
<span class="sd">                given age at time :math:`t_0`. </span>
<span class="sd">                Defaults to ``None``.</span>
<span class="sd">            F0 (Python function): A function of age that returns a </span>
<span class="sd">                ``numpy.array`` containing the masses with age less than or </span>
<span class="sd">                equal to the age at time :math:`t_0`. </span>
<span class="sd">                Defaults to ``None``.</span>
<span class="sd">            tol (float): The tolerance used in the numerical root search </span>
<span class="sd">                algorithm. A low tolerance decreases the computation speed </span>
<span class="sd">                tremendously, so a value of ``1e-01`` might already be fine. </span>
<span class="sd">                Defaults to ``1e-08``.</span>

<span class="sd">        Raises:</span>
<span class="sd">            Error: If both ``start_age_densities`` and ``F0`` are ``None``. </span>
<span class="sd">                One must be given.</span>
<span class="sd">                It is fastest to provide ``F0``, otherwise ``F0`` will be </span>
<span class="sd">                computed by numerical integration of ``start_age_densities``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: The computed quantile values over the time grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">soln</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
        <span class="c1"># check if system is empty at the beginning,</span>
        <span class="c1"># if so, then we use 0 as start value, otherwise</span>
        <span class="c1"># we need to compute it from F0 (preferably) or start_age_density</span>
        <span class="n">empty</span> <span class="o">=</span> <span class="n">soln</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">empty</span> <span class="ow">and</span> <span class="n">F0</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">start_age_densities</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span><span class="p">(</span><span class="n">Error</span><span class="p">(</span><span class="s1">&#39;Either F0 or start_age_densities must be given.&#39;</span><span class="p">))</span>
        
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
        <span class="n">original_times</span> <span class="o">=</span> <span class="n">times</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">empty</span> <span class="ow">and</span> <span class="n">F0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">p0</span> <span class="o">=</span> <span class="n">start_age_densities</span>
            <span class="n">F0</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">p0</span><span class="p">(</span><span class="n">s</span><span class="p">)[</span><span class="n">pool</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">a</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> 
                                        <span class="k">for</span> <span class="n">pool</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)])</span>
        
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">system_age_density_single_value</span><span class="p">(</span><span class="n">start_age_densities</span><span class="p">)</span>

        <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_input_vector_func</span><span class="p">()</span>
        <span class="n">F</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cumulative_pool_age_distributions_single_value</span><span class="p">(</span>
                <span class="n">start_age_densities</span><span class="o">=</span><span class="n">start_age_densities</span><span class="p">,</span> <span class="n">F0</span><span class="o">=</span><span class="n">F0</span><span class="p">)</span>
        <span class="n">sol_funcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve_single_value</span><span class="p">()</span>

        <span class="c1"># find last time index such that the system is empty --&gt; ti</span>
        <span class="n">ti</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">content</span> <span class="o">=</span> <span class="n">soln</span><span class="p">[</span><span class="n">ti</span><span class="p">,:]</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">content</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">ti</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span> 
            <span class="n">ti</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-</span><span class="mi">1</span>
            <span class="n">content</span> <span class="o">=</span> <span class="n">soln</span><span class="p">[</span><span class="n">ti</span><span class="p">,:]</span>
        
        <span class="k">if</span> <span class="n">content</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">ti</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ti</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)):</span> <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">),))</span>
  
        <span class="k">if</span> <span class="n">ti</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">sv</span> <span class="o">=</span> <span class="n">generalized_inverse_CDF</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">F0</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> 
                                         <span class="n">quantile</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">start_values</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#if start_age_densities is None:</span>
            <span class="c1">#    raise(Error(&#39;Cannot start delayed quantile computation,&#39;</span>
            <span class="c1">#                    &#39;since start_age_Densities are missing.&#39;))</span>
            <span class="n">CDFs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cumulative_system_age_distribution_single_value</span><span class="p">(</span>
                            <span class="n">start_age_densities</span><span class="p">)</span>
            <span class="n">CDF</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">CDFs</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">times</span><span class="p">[</span><span class="n">ti</span><span class="p">])</span>
            <span class="n">sv</span> <span class="o">=</span> <span class="n">generalized_inverse_CDF</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="n">quantile</span><span class="o">*</span><span class="n">soln</span><span class="p">[</span><span class="n">ti</span><span class="p">,:]</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>

        <span class="n">times</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="n">ti</span><span class="p">:]</span>

        <span class="n">t_max</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">t_min</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">pb</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">total</span> <span class="o">=</span> <span class="n">t_max</span><span class="o">-</span><span class="n">t_min</span><span class="p">)</span>

        <span class="k">global</span> <span class="n">last_t</span><span class="p">,</span> <span class="n">last_res</span>
        <span class="n">last_t</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">last_res</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>

        <span class="k">def</span> <span class="nf">rhs</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">t_val</span><span class="p">):</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
            <span class="k">global</span> <span class="n">last_t</span><span class="p">,</span> <span class="n">last_res</span>
            
            <span class="n">t_val</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">t_val</span><span class="p">,</span> <span class="n">t_max</span><span class="p">)</span>

            <span class="c1"># rhs will be called twice with the same value apparently,  </span>
            <span class="c1"># we can use this to speed it up</span>
            <span class="k">if</span> <span class="n">t_val</span> <span class="o">==</span> <span class="n">last_t</span><span class="p">:</span> <span class="k">return</span> <span class="n">last_res</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">t_val</span> <span class="o">&lt;=</span> <span class="n">t_max</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">t_val</span><span class="o">-</span><span class="n">t_min</span><span class="o">-</span><span class="n">pb</span><span class="o">.</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                <span class="c1">#pb.n = t_val-t_min</span>
                <span class="c1">#pb.update(0)</span>
                <span class="n">pb</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">t_val</span><span class="o">-</span><span class="n">t_min</span><span class="o">-</span><span class="n">pb</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>

            <span class="c1">#pb.update(t_val-t_min, n=0)</span>
            <span class="c1">#print()</span>
            <span class="c1">#print(&#39;y&#39;, y, &#39;t&#39;, t_val)</span>
        
            <span class="n">p_val</span> <span class="o">=</span> <span class="n">p</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">t_val</span><span class="p">)</span>
            <span class="n">u_vec</span> <span class="o">=</span> <span class="n">u</span><span class="p">(</span><span class="n">t_val</span><span class="p">)</span>
            <span class="n">F_vec</span> <span class="o">=</span> <span class="n">F</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">t_val</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">x_vec</span> <span class="o">=</span> <span class="n">sol_funcs</span><span class="p">(</span><span class="n">t_val</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">(</span><span class="n">t_val</span><span class="p">)</span>

            <span class="c1">#print(&#39;A&#39;, A)</span>
            <span class="c1">#print(&#39;x&#39;, x_vec)</span>
            <span class="c1">#print(&#39;A*x&#39;, A.dot(x_vec))</span>
            <span class="c1">#print(&#39;p&#39;, p_val)</span>
            <span class="c1">#print(&#39;u&#39;, u_vec)</span>
            <span class="c1">#print(&#39;F&#39;, F_vec)</span>
            <span class="c1">#print(&#39;A*F&#39;, A.dot(F_vec))</span>

            <span class="c1">#print(F_val/x_val.sum()*((A*x_val).sum()-(A*F_val).sum()))</span>
            <span class="k">if</span> <span class="n">p_val</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span><span class="p">(</span><span class="n">Error</span><span class="p">(</span><span class="s1">&#39;Division by zero during quantile computation.&#39;</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">p_val</span><span class="o">*</span><span class="p">(</span><span class="n">u_vec</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">*</span><span class="p">(</span><span class="n">quantile</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)</span><span class="o">+</span>
                            <span class="n">quantile</span><span class="o">*</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x_vec</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">-</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">F_vec</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()))</span>
            <span class="c1">#print(&#39;res&#39;, res)</span>

            <span class="n">last_t</span> <span class="o">=</span> <span class="n">t_val</span>
            <span class="n">last_res</span> <span class="o">=</span> <span class="n">res</span>
            <span class="k">return</span> <span class="n">res</span>

        <span class="n">short_res</span> <span class="o">=</span> <span class="n">odeint</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">sv</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span> <span class="n">mxstep</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
        <span class="n">pb</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">original_times</span><span class="p">),))</span>
        <span class="n">res</span><span class="p">[:</span><span class="n">ti</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">res</span><span class="p">[</span><span class="n">ti</span><span class="p">:]</span> <span class="o">=</span> <span class="n">short_res</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">),))</span>

        <span class="c1">#print(res)</span>
        <span class="k">return</span> <span class="n">res</span></div>


    <span class="c1">########## private methods #########</span>


    <span class="k">def</span> <span class="nf">_solve_age_moment_system_single_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_order</span><span class="p">,</span> 
            <span class="n">start_age_moments</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">start_values</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">t0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">t_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">t0</span><span class="p">:</span>
                <span class="c1"># times x pools </span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span><span class="p">))</span>
                <span class="n">res</span><span class="p">[</span><span class="n">res</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="k">return</span> <span class="n">res</span>
            
            <span class="c1">#fixme: do we really want to cut off here? </span>
            <span class="k">if</span> <span class="n">t</span> <span class="o">&gt;</span> <span class="n">t_max</span><span class="p">:</span> <span class="n">t</span> <span class="o">=</span> <span class="n">t_max</span>

            <span class="n">new_times</span> <span class="o">=</span> <span class="p">[</span><span class="n">t0</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span>
            <span class="n">soln</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_solve_age_moment_system</span><span class="p">(</span><span class="n">max_order</span><span class="p">,</span> 
                                                 <span class="n">start_age_moments</span><span class="p">,</span> 
                                                 <span class="n">times</span><span class="o">=</span><span class="n">new_times</span><span class="p">,</span> 
                                                 <span class="n">start_values</span><span class="o">=</span><span class="n">start_values</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">soln</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">func</span> 

    <span class="k">def</span> <span class="nf">_solve_age_moment_system</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_order</span><span class="p">,</span> 
            <span class="n">start_age_moments</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">times</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">start_values</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">store</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="c1">#store = True</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">((</span><span class="n">times</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">start_values</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)):</span> <span class="n">store</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">times</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> 
            <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>

        <span class="k">if</span> <span class="n">start_values</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">start_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_values</span>

        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">start_values</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="c1">#print(start_values)</span>
            <span class="k">raise</span><span class="p">(</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;start_values should be a numpy array&quot;</span><span class="p">))</span>

        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>
        <span class="k">if</span> <span class="n">start_age_moments</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start_age_moments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">max_order</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
        
        <span class="n">start_age_moments_list</span> <span class="o">=</span> <span class="n">flatten</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> 
                            <span class="p">[</span><span class="n">start_age_moments</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> 
                                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start_age_moments</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]])</span>
       
        <span class="n">storage_key</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">start_age_moments_list</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="n">max_order</span><span class="p">,),)</span>

        <span class="c1"># return cached result if possible</span>
        <span class="k">if</span> <span class="n">store</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_previously_computed_age_moment_sol&quot;</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">storage_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_previously_computed_age_moment_sol</span><span class="p">:</span>
                    <span class="c1">#print(&#39;using cached age moment system:&#39;, storage_key)</span>
                    <span class="c1">#print(</span>
                    <span class="c1">#   self._previously_computed_age_moment_sol[storage_key])</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_previously_computed_age_moment_sol</span><span class="p">[</span><span class="n">storage_key</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_previously_computed_age_moment_sol</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">srm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span>
        <span class="n">state_vector</span><span class="p">,</span> <span class="n">rhs</span> <span class="o">=</span> <span class="n">srm</span><span class="o">.</span><span class="n">age_moment_system</span><span class="p">(</span><span class="n">max_order</span><span class="p">)</span>
       
        <span class="c1"># compute solution</span>
        <span class="n">new_start_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="o">*</span><span class="p">(</span><span class="n">max_order</span><span class="o">+</span><span class="mi">1</span><span class="p">),))</span>
        <span class="n">new_start_values</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">start_values</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">n</span><span class="p">,))</span> 
        <span class="n">new_start_values</span><span class="p">[</span><span class="n">n</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">start_age_moments_list</span><span class="p">))</span>

        <span class="n">soln</span> <span class="o">=</span> <span class="n">numsol_symbolic_system</span><span class="p">(</span>
            <span class="n">state_vector</span><span class="p">,</span>
            <span class="n">srm</span><span class="o">.</span><span class="n">time_symbol</span><span class="p">,</span>
            <span class="n">rhs</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parameter_set</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">func_set</span><span class="p">,</span>
            <span class="n">new_start_values</span><span class="p">,</span> 
            <span class="n">times</span>
        <span class="p">)</span>
        
        <span class="c1"># save all solutions for order &lt;= max_order</span>
        <span class="k">if</span> <span class="n">store</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">order</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_order</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">shorter_start_age_moments_list</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">start_age_moments_list</span><span class="p">[:</span><span class="n">order</span><span class="o">*</span><span class="n">n</span><span class="p">])</span>
                <span class="c1">#print(start_age_moments_list)</span>
                <span class="c1">#print(shorter_start_age_moments_list)</span>
                <span class="n">storage_key</span> <span class="o">=</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">shorter_start_age_moments_list</span><span class="p">)</span> 
                                <span class="o">+</span> <span class="p">((</span><span class="n">order</span><span class="p">,),))</span>
                <span class="c1">#print(&#39;saving&#39;, storage_key)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_previously_computed_age_moment_sol</span><span class="p">[</span><span class="n">storage_key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">soln</span><span class="p">[:,:(</span><span class="n">order</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">n</span><span class="p">])</span>
                <span class="c1">#print(self._previously_computed_age_moment_sol[storage_key])</span>

        <span class="k">return</span> <span class="n">soln</span>

    <span class="c1">#fixme: test</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_no_input_sol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_saved_no_input_sol&#39;</span><span class="p">):</span>
            <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span>
            <span class="n">m_no_inputs</span> <span class="o">=</span> <span class="n">SmoothReservoirModel</span><span class="p">(</span>
                    <span class="n">m</span><span class="o">.</span><span class="n">state_vector</span><span class="p">,</span>
                    <span class="n">m</span><span class="o">.</span><span class="n">time_symbol</span><span class="p">,</span>
                    <span class="p">{},</span>
                    <span class="n">m</span><span class="o">.</span><span class="n">output_fluxes</span><span class="p">,</span>
                    <span class="n">m</span><span class="o">.</span><span class="n">internal_fluxes</span><span class="p">)</span>
            
            <span class="n">no_inputs_num_rhs</span> <span class="o">=</span> <span class="n">numerical_rhs</span><span class="p">(</span>
                <span class="n">m_no_inputs</span><span class="o">.</span><span class="n">state_vector</span><span class="p">,</span> 
                <span class="n">m_no_inputs</span><span class="o">.</span><span class="n">time_symbol</span><span class="p">,</span> 
                <span class="n">m_no_inputs</span><span class="o">.</span><span class="n">F</span><span class="p">,</span> 
                <span class="bp">self</span><span class="o">.</span><span class="n">parameter_set</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">func_set</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">)</span>
    
            <span class="k">def</span> <span class="nf">no_input_sol</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">start_vector</span><span class="p">):</span>
                <span class="c1">#print(&#39;nos&#39;, times, start_vector)</span>
                <span class="c1"># Start and end time too close together? Do not integrate!</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mf">1e-14</span><span class="p">:</span> 
                    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">start_vector</span><span class="p">)</span>
                <span class="n">sv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">start_vector</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span><span class="p">,))</span>
                <span class="k">return</span> <span class="n">odeint</span><span class="p">(</span><span class="n">no_inputs_num_rhs</span><span class="p">,</span> <span class="n">sv</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">mxstep</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        
            <span class="bp">self</span><span class="o">.</span><span class="n">_saved_no_input_sol</span> <span class="o">=</span> <span class="n">no_input_sol</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_saved_no_input_sol</span>

    <span class="c1">#fixme: test</span>
    <span class="k">def</span> <span class="nf">build_state_transition_operator_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">101</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">size</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span><span class="p">(</span><span class="n">Error</span><span class="p">(</span><span class="s1">&#39;Cache size must be at least 2&#39;</span><span class="p">))</span>

        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>
        <span class="n">t_min</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">t_max</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">nc</span> <span class="o">=</span> <span class="n">size</span>
        <span class="n">cached_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">t_min</span><span class="p">,</span> <span class="n">t_max</span><span class="p">,</span> <span class="n">nc</span><span class="p">)</span>

        <span class="c1"># build cache</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;creating cache&quot;</span><span class="p">)</span>
        <span class="n">ca</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="n">nc</span><span class="p">,</span> <span class="n">nc</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
        <span class="n">ca</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nc</span><span class="p">,</span> <span class="n">nc</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span> 
        <span class="n">no_input_sol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_no_input_sol</span>

        <span class="k">for</span> <span class="n">tm1_index</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nc</span><span class="o">-</span><span class="mi">1</span><span class="p">)):</span>
            <span class="n">tm1</span> <span class="o">=</span> <span class="n">cached_times</span><span class="p">[</span><span class="n">tm1_index</span><span class="p">]</span>
            <span class="n">sub_cached_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">tm1</span><span class="p">,</span> <span class="n">t_max</span><span class="p">,</span> <span class="n">nc</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">e_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
                <span class="n">e_i</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="c1">#ca[tm1_index,:,:,i] = no_input_sol(sub_cached_times, e_i) </span>
                <span class="c1"># leads to zig-zag functions, </span>
                <span class="c1"># the ends do not fit together</span>
                <span class="n">sv</span> <span class="o">=</span> <span class="n">e_i</span>
                <span class="n">st</span> <span class="o">=</span> <span class="n">tm1</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sub_cached_times</span><span class="p">)):</span>
                    <span class="n">new_sv</span> <span class="o">=</span> <span class="n">no_input_sol</span><span class="p">([</span><span class="n">st</span><span class="p">,</span> <span class="n">sub_cached_times</span><span class="p">[</span><span class="n">j</span><span class="p">]],</span> <span class="n">sv</span><span class="p">)</span>
                    <span class="n">ca</span><span class="p">[</span><span class="n">tm1_index</span><span class="p">,</span><span class="n">j</span><span class="p">,:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_sv</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">n</span><span class="p">,))</span>
                    <span class="n">sv</span> <span class="o">=</span> <span class="n">new_sv</span>
                    <span class="n">st</span> <span class="o">=</span> <span class="n">sub_cached_times</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;cache created&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_state_transition_operator_values</span> <span class="o">=</span> <span class="n">ca</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache_size</span> <span class="o">=</span> <span class="n">size</span>

    <span class="k">def</span> <span class="nf">save_state_transition_operator_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="n">cache</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;values&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state_transition_operator_values</span><span class="p">,</span>
                 <span class="s1">&#39;size&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache_size</span><span class="p">,</span>
                 <span class="s1">&#39;times&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">}</span>
        
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">output</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">load_state_transition_operator_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">output</span><span class="p">:</span>
            <span class="n">cache</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
    
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span> <span class="o">==</span> <span class="n">cache</span><span class="p">[</span><span class="s1">&#39;times&#39;</span><span class="p">]):</span>
            <span class="k">raise</span><span class="p">(</span><span class="n">Error</span><span class="p">(</span><span class="s1">&#39;The cached state transition operator does not &#39;</span>
                        <span class="s1">&#39;correspond to the current setting.&#39;</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_state_transition_operator_values</span> <span class="o">=</span> <span class="n">cache</span><span class="p">[</span><span class="s1">&#39;values&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache_size</span> <span class="o">=</span> <span class="n">cache</span><span class="p">[</span><span class="s1">&#39;size&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_state_transition_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">t0</span> <span class="o">&gt;</span> <span class="n">t</span><span class="p">:</span>
            <span class="k">raise</span><span class="p">(</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;Evaluation before t0 is not possible&quot;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">t0</span> <span class="o">==</span> <span class="n">t</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span>
       
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>
        <span class="n">no_input_sol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_no_input_sol</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state_transition_operator_values</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># do not use the cache, it has not yet been created</span>
            <span class="c1">#self.build_state_transition_operator_cache()</span>
            <span class="n">soln</span> <span class="o">=</span> <span class="p">(</span><span class="n">no_input_sol</span><span class="p">([</span><span class="n">t0</span><span class="p">,</span> <span class="n">t</span><span class="p">],</span> <span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">n</span><span class="p">,))</span>        
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># use the already created cache</span>
            <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
            <span class="n">t_min</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">t_max</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">nc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache_size</span>
    
            <span class="n">cached_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">t_min</span><span class="p">,</span> <span class="n">t_max</span><span class="p">,</span> <span class="n">nc</span><span class="p">)</span>
            <span class="n">ca</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state_transition_operator_values</span>
    
            <span class="c1"># find tm1</span>
            <span class="n">tm1_ind</span> <span class="o">=</span> <span class="n">cached_times</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">t0</span><span class="p">)</span>
            <span class="n">tm1</span> <span class="o">=</span> <span class="n">cached_times</span><span class="p">[</span><span class="n">tm1_ind</span><span class="p">]</span>
    
            <span class="c1"># check if next cached time is already behind t</span>
            <span class="k">if</span> <span class="n">t</span> <span class="o">&lt;=</span> <span class="n">tm1</span><span class="p">:</span> <span class="k">return</span> <span class="n">no_input_sol</span><span class="p">([</span><span class="n">t0</span><span class="p">,</span> <span class="n">t</span><span class="p">],</span> <span class="n">x</span><span class="p">)</span>
    
            <span class="c1"># first integrate x to tm1: y = Phi(tm1, t_0)x</span>
            <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">no_input_sol</span><span class="p">([</span><span class="n">t0</span><span class="p">,</span> <span class="n">tm1</span><span class="p">],</span> <span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
    
            <span class="n">step_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">t_max</span><span class="o">-</span><span class="n">tm1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">nc</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">step_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">tm2_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="n">t</span><span class="o">-</span><span class="n">tm1</span><span class="p">)</span><span class="o">/</span><span class="n">step_size</span><span class="p">),</span> <span class="n">nc</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
                <span class="n">tm2</span> <span class="o">=</span> <span class="n">tm1</span> <span class="o">+</span> <span class="n">tm2_ind</span><span class="o">*</span><span class="n">step_size</span>
    
                <span class="c1">#print(t, t0, t==t0, tm1_ind, tm1, tm2_ind, tm2, step_size) </span>
                <span class="n">B</span> <span class="o">=</span> <span class="n">ca</span><span class="p">[</span><span class="n">tm1_ind</span><span class="p">,</span><span class="n">tm2_ind</span><span class="p">,:,:]</span>
                <span class="c1">#print(t, t0, tm1, tm2, step_size, B)</span>
                
                <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tm2</span> <span class="o">=</span> <span class="n">tm1</span>
                <span class="n">z</span> <span class="o">=</span> <span class="n">y</span>
            <span class="c1">#z = (no_input_sol([tm1, tm2], y)[-1]).reshape((n,))</span>
    
            <span class="c1"># integrate z to t: sol=Phi(t,tm2)*z</span>
            <span class="n">soln</span> <span class="o">=</span> <span class="p">(</span><span class="n">no_input_sol</span><span class="p">([</span><span class="n">tm2</span><span class="p">,</span> <span class="n">t</span><span class="p">],</span><span class="n">z</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">n</span><span class="p">,))</span>
    
        <span class="k">return</span> <span class="n">soln</span>
        

    <span class="k">def</span> <span class="nf">_flux_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flux_vec_symbolic</span><span class="p">):</span>
        <span class="n">sol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
        <span class="n">srm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
        
        <span class="n">tup</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">srm</span><span class="o">.</span><span class="n">state_vector</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">srm</span><span class="o">.</span><span class="n">time_symbol</span><span class="p">,)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">),</span> <span class="n">n</span><span class="p">))</span>
        
        <span class="n">flux_vec_symbolic</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">flux_vec_symbolic</span><span class="p">,</span> <span class="nb">locals</span> <span class="o">=</span> <span class="n">_clash</span><span class="p">)</span>
        <span class="n">flux_vec_symbolic</span> <span class="o">=</span> <span class="n">flux_vec_symbolic</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameter_set</span><span class="p">)</span>
        <span class="n">cut_func_set</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">[:</span><span class="n">key</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;(&#39;</span><span class="p">)]:</span> <span class="n">val</span> 
                            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_set</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">flux_vec_fun</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span><span class="n">tup</span><span class="p">,</span> 
                                <span class="n">flux_vec_symbolic</span><span class="p">,</span> 
                                <span class="n">modules</span><span class="o">=</span><span class="p">[</span><span class="n">cut_func_set</span><span class="p">,</span> <span class="s1">&#39;numpy&#39;</span><span class="p">])</span>

        <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">),</span> <span class="n">n</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">ti</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)):</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">sol</span><span class="p">[</span><span class="n">ti</span><span class="p">,</span> <span class="n">pool</span><span class="p">]</span> <span class="k">for</span> <span class="n">pool</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[</span><span class="n">times</span><span class="p">[</span><span class="n">ti</span><span class="p">]]</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">flux_vec_fun</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
            <span class="n">res</span><span class="p">[</span><span class="n">ti</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">n</span><span class="p">,))</span>

        <span class="k">return</span> <span class="n">res</span>


    <span class="c1">##### age density methods #####</span>


    <span class="k">def</span> <span class="nf">_age_densities_1_single_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_age_densities</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="c1"># for part that comes from initial value</span>
        <span class="k">if</span> <span class="n">start_age_densities</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># all mass is assumed to have age 0 at the beginning</span>
            <span class="k">def</span> <span class="nf">start_age_densities</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">a</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">0</span><span class="p">,)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start_values</span><span class="p">)</span>

        <span class="c1"># cut off negative ages in start_age_densities</span>
        <span class="k">def</span> <span class="nf">p0</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">a</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span> 
                <span class="k">return</span> <span class="n">start_age_densities</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span><span class="p">,))</span>

        <span class="n">Phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state_transition_operator</span>
 
        <span class="n">t0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1">#ppp = lambda a, t: self._state_transition_operator(t,t0,p0(a-(t-t0)))</span>
        <span class="k">def</span> <span class="nf">ppp</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
            <span class="c1">#print(&#39;iv: &#39;, a, t)</span>

            <span class="c1">#fixme: cut off accidental negative values</span>
            <span class="c1">#print(&#39;Y&#39;, a-(t-t0), p0(a-t-t0))</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">Phi</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">p0</span><span class="p">(</span><span class="n">a</span><span class="o">-</span><span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="n">t0</span><span class="p">))),</span> <span class="mi">0</span><span class="p">)</span>
            <span class="c1">#print(&#39;ppp:&#39;, res)</span>
            <span class="k">return</span> <span class="n">res</span>

        <span class="k">return</span> <span class="n">ppp</span>

    <span class="c1"># return a function p1 that takes an age np.array</span>
    <span class="c1"># and gives back an nd array (age, time, pool)</span>
    <span class="k">def</span> <span class="nf">_age_densities_1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_age_densities</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="c1"># for part that comes from initial value</span>

        <span class="n">ppp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_age_densities_1_single_value</span><span class="p">(</span><span class="n">start_age_densities</span><span class="p">)</span>
        <span class="n">pp</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ppp</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">ages</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">pp</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">ages</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">p1</span>
        
    <span class="k">def</span> <span class="nf">_age_densities_2_single_value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># for part that comes from the input function u</span>
       
        <span class="n">t0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_input_vector_func</span><span class="p">()</span>
        <span class="c1">#u = lambda x: np.array([1,2])</span>

        <span class="k">def</span> <span class="nf">ppp</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
            <span class="c1">#print(&#39;input&#39;, a, t)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="n">t0</span> <span class="o">&lt;=</span> <span class="n">a</span><span class="p">):</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span><span class="p">))[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">u_val</span> <span class="o">=</span> <span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="n">a</span><span class="p">)</span>
                <span class="c1">#print(&#39;u_val&#39;, u_val)</span>
                <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state_transition_operator</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="o">-</span><span class="n">a</span><span class="p">,</span> <span class="n">u_val</span><span class="p">)</span>

            <span class="c1">#fixme: cut off accidental negative values</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="c1">#print(&#39;ppp:&#39;, res)</span>
            <span class="k">return</span> <span class="n">res</span>

        <span class="k">return</span> <span class="n">ppp</span>

    <span class="c1"># returns a function p2 that takes an age array &quot;ages&quot; as argument</span>
    <span class="c1"># and gives back a three-dimensional ndarray (ages x times x pools)</span>
    <span class="k">def</span> <span class="nf">_age_densities_2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># for part that comes from the input function u</span>
        <span class="n">ppp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_age_densities_2_single_value</span><span class="p">()</span>
        <span class="n">pp</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ppp</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="n">p2</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">ages</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">pp</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">ages</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">p2</span>


    <span class="c1">##### plotting methods #####</span>
    
    
    <span class="k">def</span> <span class="nf">_density_plot_plotly</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">ages</span><span class="p">,</span> <span class="n">age_stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">time_stride</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>

        <span class="n">strided_field</span> <span class="o">=</span> <span class="n">stride</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="p">(</span><span class="n">age_stride</span><span class="p">,</span> <span class="n">time_stride</span><span class="p">))</span>
        <span class="n">strided_ages</span> <span class="o">=</span> <span class="n">stride</span><span class="p">(</span><span class="n">ages</span><span class="p">,</span> <span class="n">age_stride</span><span class="p">)</span>
        <span class="n">strided_times</span> <span class="o">=</span> <span class="n">stride</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">time_stride</span><span class="p">)</span>
 
        <span class="n">surfacecolor</span> <span class="o">=</span> <span class="n">strided_field</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">ai</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">strided_field</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">ti</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">strided_field</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">surfacecolor</span><span class="p">[</span><span class="n">ai</span><span class="p">,</span><span class="n">ti</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="p">(</span><span class="n">ai</span> <span class="o">-</span> <span class="n">ti</span><span class="p">)</span>
        
        <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">go</span><span class="o">.</span><span class="n">Surface</span><span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="n">strided_times</span><span class="p">,</span> 
                           <span class="n">y</span> <span class="o">=</span> <span class="n">strided_ages</span><span class="p">,</span> 
                           <span class="n">z</span> <span class="o">=</span> <span class="n">strided_field</span><span class="p">,</span> 
                           <span class="n">showscale</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
                           <span class="n">surfacecolor</span> <span class="o">=</span> <span class="n">surfacecolor</span><span class="p">,</span> 
                           <span class="n">colorscale</span> <span class="o">=</span> <span class="s1">&#39;Rainbow&#39;</span><span class="p">)]</span>
        
        <span class="n">tickvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">strided_times</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">strided_times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">5</span><span class="p">)</span>
        <span class="n">ticktext</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">tickvals</span><span class="p">]</span>
        <span class="n">tickvals</span> <span class="o">=</span> <span class="o">-</span><span class="n">tickvals</span>
        
        <span class="n">layout</span> <span class="o">=</span> <span class="n">go</span><span class="o">.</span><span class="n">Layout</span><span class="p">(</span>
            <span class="n">width</span> <span class="o">=</span> <span class="mi">800</span><span class="p">,</span>
            <span class="n">height</span> <span class="o">=</span> <span class="mi">800</span><span class="p">,</span>
            <span class="n">scene</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                <span class="n">xaxis</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                    <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Time&#39;</span><span class="p">,</span>
                    <span class="n">tickmode</span> <span class="o">=</span> <span class="s1">&#39;array&#39;</span><span class="p">,</span>
                    <span class="n">tickvals</span> <span class="o">=</span> <span class="n">tickvals</span><span class="p">,</span>
                    <span class="n">ticktext</span> <span class="o">=</span> <span class="n">ticktext</span>
                    <span class="c1">#range = [-times[0], -times[-1]]</span>
                <span class="p">),</span>
                <span class="n">yaxis</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                    <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Age&#39;</span><span class="p">,</span>
                    <span class="nb">range</span> <span class="o">=</span> <span class="p">[</span><span class="n">ages</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ages</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                <span class="p">),</span>
                <span class="n">zaxis</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                    <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Mass&#39;</span><span class="p">,</span>
                    <span class="nb">range</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">strided_field</span><span class="p">)]</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">data</span><span class="p">,</span> <span class="n">layout</span>


    <span class="c1">## plot helper methods ##</span>

    <span class="c1">#fixme: unit treatment disabled</span>
    <span class="k">def</span> <span class="nf">_add_time_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
        <span class="c1">#if self.model.time_unit:</span>
        <span class="c1">#    label += r&quot;$\quad(\mathrm{&quot; + latex(self.model.time_unit) + &quot;})$&quot;</span>

        <span class="k">return</span> <span class="n">label</span>

    <span class="k">def</span> <span class="nf">_add_content_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
        <span class="c1">#if self.model.content_unit:</span>
        <span class="c1">#    label +=r&quot;$\quad(\mathrm{&quot; + latex(self.model.content_unit) + &quot;})$&quot;</span>

        <span class="k">return</span> <span class="n">label</span>

    <span class="k">def</span> <span class="nf">_add_flux_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
        <span class="c1">#if self.model.content_unit and self.model.time_unit:</span>
        <span class="c1">#    label += r&quot;$\quad(\mathrm{&quot; + latex(self.model.content_unit) </span>
        <span class="c1">#    label += &quot;/&quot; + latex(self.model.time_unit) + &quot;})$&quot;</span>
        
        <span class="k">return</span> <span class="n">label</span>


    <span class="c1">## flux helper functions ##</span>

 
    <span class="c1">#fixme: test and move</span>
    <span class="k">def</span> <span class="nf">_f_of_t_maker</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">sol_funcs</span><span class="p">,</span><span class="n">ol</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">ot</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
            <span class="n">sv</span> <span class="o">=</span> <span class="p">[</span><span class="n">sol_funcs</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span><span class="p">)]</span>
            <span class="n">tup</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">sv</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">t</span><span class="p">,)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">ol</span><span class="p">(</span><span class="o">*</span><span class="n">tup</span><span class="p">)</span>
            <span class="k">return</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
        <span class="k">return</span><span class="p">(</span><span class="n">ot</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_flux_funcs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr_dict</span><span class="p">):</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span>
        <span class="n">sol_funcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sol_funcs</span><span class="p">()</span>
        <span class="n">flux_funcs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">tup</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">state_variables</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">time_symbol</span><span class="p">,)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">expr_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">o_par</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">locals</span><span class="o">=</span><span class="n">_clash</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameter_set</span><span class="p">)</span>
            <span class="n">cut_func_set</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">[:</span><span class="n">key</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;(&#39;</span><span class="p">)]:</span> <span class="n">val</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> 
                                    <span class="bp">self</span><span class="o">.</span><span class="n">func_set</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="n">ol</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span><span class="n">tup</span><span class="p">,</span> <span class="n">o_par</span><span class="p">,</span> <span class="n">modules</span> <span class="o">=</span> <span class="p">[</span><span class="n">cut_func_set</span><span class="p">,</span> <span class="s1">&#39;numpy&#39;</span><span class="p">])</span>
            <span class="n">flux_funcs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f_of_t_maker</span><span class="p">(</span><span class="n">sol_funcs</span><span class="p">,</span> <span class="n">ol</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">flux_funcs</span></div>


 

</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">CompartmentalSystems</a></h1>










<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Holger Metzler, Markus Mller.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.4.5+</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
    </div>

    

    
  </body>
</html>